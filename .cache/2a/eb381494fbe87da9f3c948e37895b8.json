{"id":"../node_modules/@dreamirl/dreamengine/node_modules/pixi.js/lib/core/graphics/Graphics.js","dependencies":[{"name":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\graphics\\Graphics.js.map","includedInParent":true,"mtime":1505920119000},{"name":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\package.json","includedInParent":true,"mtime":1548525594111},{"name":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\package.json","includedInParent":true,"mtime":1548517163228},{"name":"../display/Container","loc":{"line":5,"column":26},"parent":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\graphics\\Graphics.js","resolved":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\display\\Container.js"},{"name":"../textures/RenderTexture","loc":{"line":9,"column":29},"parent":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\graphics\\Graphics.js","resolved":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\textures\\RenderTexture.js"},{"name":"../textures/Texture","loc":{"line":13,"column":23},"parent":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\graphics\\Graphics.js","resolved":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\textures\\Texture.js"},{"name":"./GraphicsData","loc":{"line":17,"column":28},"parent":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\graphics\\Graphics.js","resolved":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\graphics\\GraphicsData.js"},{"name":"../sprites/Sprite","loc":{"line":21,"column":22},"parent":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\graphics\\Graphics.js","resolved":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\sprites\\Sprite.js"},{"name":"../math","loc":{"line":25,"column":20},"parent":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\graphics\\Graphics.js","resolved":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\math\\index.js"},{"name":"../utils","loc":{"line":27,"column":21},"parent":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\graphics\\Graphics.js","resolved":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\utils\\index.js"},{"name":"../const","loc":{"line":29,"column":21},"parent":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\graphics\\Graphics.js","resolved":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\const.js"},{"name":"../display/Bounds","loc":{"line":31,"column":22},"parent":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\graphics\\Graphics.js","resolved":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\display\\Bounds.js"},{"name":"./utils/bezierCurveTo","loc":{"line":35,"column":30},"parent":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\graphics\\Graphics.js","resolved":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\graphics\\utils\\bezierCurveTo.js"},{"name":"../renderers/canvas/CanvasRenderer","loc":{"line":39,"column":30},"parent":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\graphics\\Graphics.js","resolved":"C:\\Users\\Grimka\\Documents\\GitHub\\GGJ19\\node_modules\\@dreamirl\\dreamengine\\node_modules\\pixi.js\\lib\\core\\renderers\\canvas\\CanvasRenderer.js"}],"generated":{"js":"'use strict';\n\nexports.__esModule = true;\n\nvar _Container2 = require('../display/Container');\n\nvar _Container3 = _interopRequireDefault(_Container2);\n\nvar _RenderTexture = require('../textures/RenderTexture');\n\nvar _RenderTexture2 = _interopRequireDefault(_RenderTexture);\n\nvar _Texture = require('../textures/Texture');\n\nvar _Texture2 = _interopRequireDefault(_Texture);\n\nvar _GraphicsData = require('./GraphicsData');\n\nvar _GraphicsData2 = _interopRequireDefault(_GraphicsData);\n\nvar _Sprite = require('../sprites/Sprite');\n\nvar _Sprite2 = _interopRequireDefault(_Sprite);\n\nvar _math = require('../math');\n\nvar _utils = require('../utils');\n\nvar _const = require('../const');\n\nvar _Bounds = require('../display/Bounds');\n\nvar _Bounds2 = _interopRequireDefault(_Bounds);\n\nvar _bezierCurveTo2 = require('./utils/bezierCurveTo');\n\nvar _bezierCurveTo3 = _interopRequireDefault(_bezierCurveTo2);\n\nvar _CanvasRenderer = require('../renderers/canvas/CanvasRenderer');\n\nvar _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar canvasRenderer = void 0;\nvar tempMatrix = new _math.Matrix();\nvar tempPoint = new _math.Point();\nvar tempColor1 = new Float32Array(4);\nvar tempColor2 = new Float32Array(4);\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\n\nvar Graphics = function (_Container) {\n    _inherits(Graphics, _Container);\n\n    /**\n     *\n     * @param {boolean} [nativeLines=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     */\n    function Graphics() {\n        var nativeLines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n        _classCallCheck(this, Graphics);\n\n        /**\n         * The alpha value used when filling the Graphics object.\n         *\n         * @member {number}\n         * @default 1\n         */\n        var _this = _possibleConstructorReturn(this, _Container.call(this));\n\n        _this.fillAlpha = 1;\n\n        /**\n         * The width (thickness) of any lines drawn.\n         *\n         * @member {number}\n         * @default 0\n         */\n        _this.lineWidth = 0;\n\n        /**\n         * If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n         *\n         * @member {boolean}\n         */\n        _this.nativeLines = nativeLines;\n\n        /**\n         * The color of any lines drawn.\n         *\n         * @member {string}\n         * @default 0\n         */\n        _this.lineColor = 0;\n\n        /**\n         * Graphics data\n         *\n         * @member {PIXI.GraphicsData[]}\n         * @private\n         */\n        _this.graphicsData = [];\n\n        /**\n         * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to\n         * reset the tint.\n         *\n         * @member {number}\n         * @default 0xFFFFFF\n         */\n        _this.tint = 0xFFFFFF;\n\n        /**\n         * The previous tint applied to the graphic shape. Used to compare to the current tint and\n         * check if theres change.\n         *\n         * @member {number}\n         * @private\n         * @default 0xFFFFFF\n         */\n        _this._prevTint = 0xFFFFFF;\n\n        /**\n         * The blend mode to be applied to the graphic shape. Apply a value of\n         * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n         *\n         * @member {number}\n         * @default PIXI.BLEND_MODES.NORMAL;\n         * @see PIXI.BLEND_MODES\n         */\n        _this.blendMode = _const.BLEND_MODES.NORMAL;\n\n        /**\n         * Current path\n         *\n         * @member {PIXI.GraphicsData}\n         * @private\n         */\n        _this.currentPath = null;\n\n        /**\n         * Array containing some WebGL-related properties used by the WebGL renderer.\n         *\n         * @member {object<number, object>}\n         * @private\n         */\n        // TODO - _webgl should use a prototype object, not a random undocumented object...\n        _this._webGL = {};\n\n        /**\n         * Whether this shape is being used as a mask.\n         *\n         * @member {boolean}\n         */\n        _this.isMask = false;\n\n        /**\n         * The bounds' padding used for bounds calculation.\n         *\n         * @member {number}\n         */\n        _this.boundsPadding = 0;\n\n        /**\n         * A cache of the local bounds to prevent recalculation.\n         *\n         * @member {PIXI.Rectangle}\n         * @private\n         */\n        _this._localBounds = new _Bounds2.default();\n\n        /**\n         * Used to detect if the graphics object has changed. If this is set to true then the graphics\n         * object will be recalculated.\n         *\n         * @member {boolean}\n         * @private\n         */\n        _this.dirty = 0;\n\n        /**\n         * Used to detect if we need to do a fast rect check using the id compare method\n         * @type {Number}\n         */\n        _this.fastRectDirty = -1;\n\n        /**\n         * Used to detect if we clear the graphics webGL data\n         * @type {Number}\n         */\n        _this.clearDirty = 0;\n\n        /**\n         * Used to detect if we we need to recalculate local bounds\n         * @type {Number}\n         */\n        _this.boundsDirty = -1;\n\n        /**\n         * Used to detect if the cached sprite object needs to be updated.\n         *\n         * @member {boolean}\n         * @private\n         */\n        _this.cachedSpriteDirty = false;\n\n        _this._spriteRect = null;\n        _this._fastRect = false;\n\n        /**\n         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n         * This is useful if your graphics element does not change often, as it will speed up the rendering\n         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n         * you are constantly redrawing the graphics element.\n         *\n         * @name cacheAsBitmap\n         * @member {boolean}\n         * @memberof PIXI.Graphics#\n         * @default false\n         */\n        return _this;\n    }\n\n    /**\n     * Creates a new Graphics object with the same values as this one.\n     * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)\n     *\n     * @return {PIXI.Graphics} A clone of the graphics object\n     */\n\n\n    Graphics.prototype.clone = function clone() {\n        var clone = new Graphics();\n\n        clone.renderable = this.renderable;\n        clone.fillAlpha = this.fillAlpha;\n        clone.lineWidth = this.lineWidth;\n        clone.lineColor = this.lineColor;\n        clone.tint = this.tint;\n        clone.blendMode = this.blendMode;\n        clone.isMask = this.isMask;\n        clone.boundsPadding = this.boundsPadding;\n        clone.dirty = 0;\n        clone.cachedSpriteDirty = this.cachedSpriteDirty;\n\n        // copy graphics data\n        for (var i = 0; i < this.graphicsData.length; ++i) {\n            clone.graphicsData.push(this.graphicsData[i].clone());\n        }\n\n        clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];\n\n        clone.updateLocalBounds();\n\n        return clone;\n    };\n\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     *\n     * @param {number} [lineWidth=0] - width of the line to draw, will update the objects stored style\n     * @param {number} [color=0] - color of the line to draw, will update the objects stored style\n     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n\n\n    Graphics.prototype.lineStyle = function lineStyle() {\n        var lineWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var alpha = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n        this.lineWidth = lineWidth;\n        this.lineColor = color;\n        this.lineAlpha = alpha;\n\n        if (this.currentPath) {\n            if (this.currentPath.shape.points.length) {\n                // halfway through a line? start a new one!\n                var shape = new _math.Polygon(this.currentPath.shape.points.slice(-2));\n\n                shape.closed = false;\n\n                this.drawShape(shape);\n            } else {\n                // otherwise its empty so lets just set the line properties\n                this.currentPath.lineWidth = this.lineWidth;\n                this.currentPath.lineColor = this.lineColor;\n                this.currentPath.lineAlpha = this.lineAlpha;\n            }\n        }\n\n        return this;\n    };\n\n    /**\n     * Moves the current drawing position to x, y.\n     *\n     * @param {number} x - the X coordinate to move to\n     * @param {number} y - the Y coordinate to move to\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n\n\n    Graphics.prototype.moveTo = function moveTo(x, y) {\n        var shape = new _math.Polygon([x, y]);\n\n        shape.closed = false;\n        this.drawShape(shape);\n\n        return this;\n    };\n\n    /**\n     * Draws a line using the current line style from the current drawing position to (x, y);\n     * The current drawing position is then set to (x, y).\n     *\n     * @param {number} x - the X coordinate to draw to\n     * @param {number} y - the Y coordinate to draw to\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n\n\n    Graphics.prototype.lineTo = function lineTo(x, y) {\n        this.currentPath.shape.points.push(x, y);\n        this.dirty++;\n\n        return this;\n    };\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     *\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n\n\n    Graphics.prototype.quadraticCurveTo = function quadraticCurveTo(cpX, cpY, toX, toY) {\n        if (this.currentPath) {\n            if (this.currentPath.shape.points.length === 0) {\n                this.currentPath.shape.points = [0, 0];\n            }\n        } else {\n            this.moveTo(0, 0);\n        }\n\n        var n = 20;\n        var points = this.currentPath.shape.points;\n        var xa = 0;\n        var ya = 0;\n\n        if (points.length === 0) {\n            this.moveTo(0, 0);\n        }\n\n        var fromX = points[points.length - 2];\n        var fromY = points[points.length - 1];\n\n        for (var i = 1; i <= n; ++i) {\n            var j = i / n;\n\n            xa = fromX + (cpX - fromX) * j;\n            ya = fromY + (cpY - fromY) * j;\n\n            points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);\n        }\n\n        this.dirty++;\n\n        return this;\n    };\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n\n\n    Graphics.prototype.bezierCurveTo = function bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {\n        if (this.currentPath) {\n            if (this.currentPath.shape.points.length === 0) {\n                this.currentPath.shape.points = [0, 0];\n            }\n        } else {\n            this.moveTo(0, 0);\n        }\n\n        var points = this.currentPath.shape.points;\n\n        var fromX = points[points.length - 2];\n        var fromY = points[points.length - 1];\n\n        points.length -= 2;\n\n        (0, _bezierCurveTo3.default)(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, points);\n\n        this.dirty++;\n\n        return this;\n    };\n\n    /**\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     *\n     * @param {number} x1 - The x-coordinate of the beginning of the arc\n     * @param {number} y1 - The y-coordinate of the beginning of the arc\n     * @param {number} x2 - The x-coordinate of the end of the arc\n     * @param {number} y2 - The y-coordinate of the end of the arc\n     * @param {number} radius - The radius of the arc\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n\n\n    Graphics.prototype.arcTo = function arcTo(x1, y1, x2, y2, radius) {\n        if (this.currentPath) {\n            if (this.currentPath.shape.points.length === 0) {\n                this.currentPath.shape.points.push(x1, y1);\n            }\n        } else {\n            this.moveTo(x1, y1);\n        }\n\n        var points = this.currentPath.shape.points;\n        var fromX = points[points.length - 2];\n        var fromY = points[points.length - 1];\n        var a1 = fromY - y1;\n        var b1 = fromX - x1;\n        var a2 = y2 - y1;\n        var b2 = x2 - x1;\n        var mm = Math.abs(a1 * b2 - b1 * a2);\n\n        if (mm < 1.0e-8 || radius === 0) {\n            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n                points.push(x1, y1);\n            }\n        } else {\n            var dd = a1 * a1 + b1 * b1;\n            var cc = a2 * a2 + b2 * b2;\n            var tt = a1 * a2 + b1 * b2;\n            var k1 = radius * Math.sqrt(dd) / mm;\n            var k2 = radius * Math.sqrt(cc) / mm;\n            var j1 = k1 * tt / dd;\n            var j2 = k2 * tt / cc;\n            var cx = k1 * b2 + k2 * b1;\n            var cy = k1 * a2 + k2 * a1;\n            var px = b1 * (k2 + j1);\n            var py = a1 * (k2 + j1);\n            var qx = b2 * (k1 + j2);\n            var qy = a2 * (k1 + j2);\n            var startAngle = Math.atan2(py - cy, px - cx);\n            var endAngle = Math.atan2(qy - cy, qx - cx);\n\n            this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);\n        }\n\n        this.dirty++;\n\n        return this;\n    };\n\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     *\n     * @param {number} cx - The x-coordinate of the center of the circle\n     * @param {number} cy - The y-coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param {number} endAngle - The ending angle, in radians\n     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n\n\n    Graphics.prototype.arc = function arc(cx, cy, radius, startAngle, endAngle) {\n        var anticlockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n        if (startAngle === endAngle) {\n            return this;\n        }\n\n        if (!anticlockwise && endAngle <= startAngle) {\n            endAngle += Math.PI * 2;\n        } else if (anticlockwise && startAngle <= endAngle) {\n            startAngle += Math.PI * 2;\n        }\n\n        var sweep = endAngle - startAngle;\n        var segs = Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 40;\n\n        if (sweep === 0) {\n            return this;\n        }\n\n        var startX = cx + Math.cos(startAngle) * radius;\n        var startY = cy + Math.sin(startAngle) * radius;\n\n        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n        var points = this.currentPath ? this.currentPath.shape.points : null;\n\n        if (points) {\n            if (points[points.length - 2] !== startX || points[points.length - 1] !== startY) {\n                points.push(startX, startY);\n            }\n        } else {\n            this.moveTo(startX, startY);\n            points = this.currentPath.shape.points;\n        }\n\n        var theta = sweep / (segs * 2);\n        var theta2 = theta * 2;\n\n        var cTheta = Math.cos(theta);\n        var sTheta = Math.sin(theta);\n\n        var segMinus = segs - 1;\n\n        var remainder = segMinus % 1 / segMinus;\n\n        for (var i = 0; i <= segMinus; ++i) {\n            var real = i + remainder * i;\n\n            var angle = theta + startAngle + theta2 * real;\n\n            var c = Math.cos(angle);\n            var s = -Math.sin(angle);\n\n            points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);\n        }\n\n        this.dirty++;\n\n        return this;\n    };\n\n    /**\n     * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n     * (such as lineTo() or drawCircle()) use when drawing.\n     *\n     * @param {number} [color=0] - the color of the fill\n     * @param {number} [alpha=1] - the alpha of the fill\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n\n\n    Graphics.prototype.beginFill = function beginFill() {\n        var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n        this.filling = true;\n        this.fillColor = color;\n        this.fillAlpha = alpha;\n\n        if (this.currentPath) {\n            if (this.currentPath.shape.points.length <= 2) {\n                this.currentPath.fill = this.filling;\n                this.currentPath.fillColor = this.fillColor;\n                this.currentPath.fillAlpha = this.fillAlpha;\n            }\n        }\n\n        return this;\n    };\n\n    /**\n     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n     *\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n\n\n    Graphics.prototype.endFill = function endFill() {\n        this.filling = false;\n        this.fillColor = null;\n        this.fillAlpha = 1;\n\n        return this;\n    };\n\n    /**\n     *\n     * @param {number} x - The X coord of the top-left of the rectangle\n     * @param {number} y - The Y coord of the top-left of the rectangle\n     * @param {number} width - The width of the rectangle\n     * @param {number} height - The height of the rectangle\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n\n\n    Graphics.prototype.drawRect = function drawRect(x, y, width, height) {\n        this.drawShape(new _math.Rectangle(x, y, width, height));\n\n        return this;\n    };\n\n    /**\n     *\n     * @param {number} x - The X coord of the top-left of the rectangle\n     * @param {number} y - The Y coord of the top-left of the rectangle\n     * @param {number} width - The width of the rectangle\n     * @param {number} height - The height of the rectangle\n     * @param {number} radius - Radius of the rectangle corners\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n\n\n    Graphics.prototype.drawRoundedRect = function drawRoundedRect(x, y, width, height, radius) {\n        this.drawShape(new _math.RoundedRectangle(x, y, width, height, radius));\n\n        return this;\n    };\n\n    /**\n     * Draws a circle.\n     *\n     * @param {number} x - The X coordinate of the center of the circle\n     * @param {number} y - The Y coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n\n\n    Graphics.prototype.drawCircle = function drawCircle(x, y, radius) {\n        this.drawShape(new _math.Circle(x, y, radius));\n\n        return this;\n    };\n\n    /**\n     * Draws an ellipse.\n     *\n     * @param {number} x - The X coordinate of the center of the ellipse\n     * @param {number} y - The Y coordinate of the center of the ellipse\n     * @param {number} width - The half width of the ellipse\n     * @param {number} height - The half height of the ellipse\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n\n\n    Graphics.prototype.drawEllipse = function drawEllipse(x, y, width, height) {\n        this.drawShape(new _math.Ellipse(x, y, width, height));\n\n        return this;\n    };\n\n    /**\n     * Draws a polygon using the given path.\n     *\n     * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n\n\n    Graphics.prototype.drawPolygon = function drawPolygon(path) {\n        // prevents an argument assignment deopt\n        // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n        var points = path;\n\n        var closed = true;\n\n        if (points instanceof _math.Polygon) {\n            closed = points.closed;\n            points = points.points;\n        }\n\n        if (!Array.isArray(points)) {\n            // prevents an argument leak deopt\n            // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n            points = new Array(arguments.length);\n\n            for (var i = 0; i < points.length; ++i) {\n                points[i] = arguments[i]; // eslint-disable-line prefer-rest-params\n            }\n        }\n\n        var shape = new _math.Polygon(points);\n\n        shape.closed = closed;\n\n        this.drawShape(shape);\n\n        return this;\n    };\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     *\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n\n\n    Graphics.prototype.clear = function clear() {\n        if (this.lineWidth || this.filling || this.graphicsData.length > 0) {\n            this.lineWidth = 0;\n            this.filling = false;\n\n            this.boundsDirty = -1;\n            this.dirty++;\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        this.currentPath = null;\n        this._spriteRect = null;\n\n        return this;\n    };\n\n    /**\n     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n     * masked with gl.scissor.\n     *\n     * @returns {boolean} True if only 1 rect.\n     */\n\n\n    Graphics.prototype.isFastRect = function isFastRect() {\n        return this.graphicsData.length === 1 && this.graphicsData[0].shape.type === _const.SHAPES.RECT && !this.graphicsData[0].lineWidth;\n    };\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n\n\n    Graphics.prototype._renderWebGL = function _renderWebGL(renderer) {\n        // if the sprite is not visible or the alpha is 0 then no need to render this element\n        if (this.dirty !== this.fastRectDirty) {\n            this.fastRectDirty = this.dirty;\n            this._fastRect = this.isFastRect();\n        }\n\n        // TODO this check can be moved to dirty?\n        if (this._fastRect) {\n            this._renderSpriteRect(renderer);\n        } else {\n            renderer.setObjectRenderer(renderer.plugins.graphics);\n            renderer.plugins.graphics.render(this);\n        }\n    };\n\n    /**\n     * Renders a sprite rectangle.\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n\n\n    Graphics.prototype._renderSpriteRect = function _renderSpriteRect(renderer) {\n        var rect = this.graphicsData[0].shape;\n\n        if (!this._spriteRect) {\n            this._spriteRect = new _Sprite2.default(new _Texture2.default(_Texture2.default.WHITE));\n        }\n\n        var sprite = this._spriteRect;\n\n        if (this.tint === 0xffffff) {\n            sprite.tint = this.graphicsData[0].fillColor;\n        } else {\n            var t1 = tempColor1;\n            var t2 = tempColor2;\n\n            (0, _utils.hex2rgb)(this.graphicsData[0].fillColor, t1);\n            (0, _utils.hex2rgb)(this.tint, t2);\n\n            t1[0] *= t2[0];\n            t1[1] *= t2[1];\n            t1[2] *= t2[2];\n\n            sprite.tint = (0, _utils.rgb2hex)(t1);\n        }\n        sprite.alpha = this.graphicsData[0].fillAlpha;\n        sprite.worldAlpha = this.worldAlpha * sprite.alpha;\n        sprite.blendMode = this.blendMode;\n\n        sprite._texture._frame.width = rect.width;\n        sprite._texture._frame.height = rect.height;\n\n        sprite.transform.worldTransform = this.transform.worldTransform;\n\n        sprite.anchor.set(-rect.x / rect.width, -rect.y / rect.height);\n        sprite._onAnchorUpdate();\n\n        sprite._renderWebGL(renderer);\n    };\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n\n\n    Graphics.prototype._renderCanvas = function _renderCanvas(renderer) {\n        if (this.isMask === true) {\n            return;\n        }\n\n        renderer.plugins.graphics.render(this);\n    };\n\n    /**\n     * Retrieves the bounds of the graphic shape as a rectangle object\n     *\n     * @private\n     */\n\n\n    Graphics.prototype._calculateBounds = function _calculateBounds() {\n        if (this.boundsDirty !== this.dirty) {\n            this.boundsDirty = this.dirty;\n            this.updateLocalBounds();\n\n            this.cachedSpriteDirty = true;\n        }\n\n        var lb = this._localBounds;\n\n        this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY);\n    };\n\n    /**\n     * Tests if a point is inside this graphics object\n     *\n     * @param {PIXI.Point} point - the point to test\n     * @return {boolean} the result of the test\n     */\n\n\n    Graphics.prototype.containsPoint = function containsPoint(point) {\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        var graphicsData = this.graphicsData;\n\n        for (var i = 0; i < graphicsData.length; ++i) {\n            var data = graphicsData[i];\n\n            if (!data.fill) {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape) {\n                if (data.shape.contains(tempPoint.x, tempPoint.y)) {\n                    if (data.holes) {\n                        for (var _i = 0; _i < data.holes.length; _i++) {\n                            var hole = data.holes[_i];\n\n                            if (hole.contains(tempPoint.x, tempPoint.y)) {\n                                return false;\n                            }\n                        }\n                    }\n\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    };\n\n    /**\n     * Update the bounds of the object\n     *\n     */\n\n\n    Graphics.prototype.updateLocalBounds = function updateLocalBounds() {\n        var minX = Infinity;\n        var maxX = -Infinity;\n\n        var minY = Infinity;\n        var maxY = -Infinity;\n\n        if (this.graphicsData.length) {\n            var shape = 0;\n            var x = 0;\n            var y = 0;\n            var w = 0;\n            var h = 0;\n\n            for (var i = 0; i < this.graphicsData.length; i++) {\n                var data = this.graphicsData[i];\n                var type = data.type;\n                var lineWidth = data.lineWidth;\n\n                shape = data.shape;\n\n                if (type === _const.SHAPES.RECT || type === _const.SHAPES.RREC) {\n                    x = shape.x - lineWidth / 2;\n                    y = shape.y - lineWidth / 2;\n                    w = shape.width + lineWidth;\n                    h = shape.height + lineWidth;\n\n                    minX = x < minX ? x : minX;\n                    maxX = x + w > maxX ? x + w : maxX;\n\n                    minY = y < minY ? y : minY;\n                    maxY = y + h > maxY ? y + h : maxY;\n                } else if (type === _const.SHAPES.CIRC) {\n                    x = shape.x;\n                    y = shape.y;\n                    w = shape.radius + lineWidth / 2;\n                    h = shape.radius + lineWidth / 2;\n\n                    minX = x - w < minX ? x - w : minX;\n                    maxX = x + w > maxX ? x + w : maxX;\n\n                    minY = y - h < minY ? y - h : minY;\n                    maxY = y + h > maxY ? y + h : maxY;\n                } else if (type === _const.SHAPES.ELIP) {\n                    x = shape.x;\n                    y = shape.y;\n                    w = shape.width + lineWidth / 2;\n                    h = shape.height + lineWidth / 2;\n\n                    minX = x - w < minX ? x - w : minX;\n                    maxX = x + w > maxX ? x + w : maxX;\n\n                    minY = y - h < minY ? y - h : minY;\n                    maxY = y + h > maxY ? y + h : maxY;\n                } else {\n                    // POLY\n                    var points = shape.points;\n                    var x2 = 0;\n                    var y2 = 0;\n                    var dx = 0;\n                    var dy = 0;\n                    var rw = 0;\n                    var rh = 0;\n                    var cx = 0;\n                    var cy = 0;\n\n                    for (var j = 0; j + 2 < points.length; j += 2) {\n                        x = points[j];\n                        y = points[j + 1];\n                        x2 = points[j + 2];\n                        y2 = points[j + 3];\n                        dx = Math.abs(x2 - x);\n                        dy = Math.abs(y2 - y);\n                        h = lineWidth;\n                        w = Math.sqrt(dx * dx + dy * dy);\n\n                        if (w < 1e-9) {\n                            continue;\n                        }\n\n                        rw = (h / w * dy + dx) / 2;\n                        rh = (h / w * dx + dy) / 2;\n                        cx = (x2 + x) / 2;\n                        cy = (y2 + y) / 2;\n\n                        minX = cx - rw < minX ? cx - rw : minX;\n                        maxX = cx + rw > maxX ? cx + rw : maxX;\n\n                        minY = cy - rh < minY ? cy - rh : minY;\n                        maxY = cy + rh > maxY ? cy + rh : maxY;\n                    }\n                }\n            }\n        } else {\n            minX = 0;\n            maxX = 0;\n            minY = 0;\n            maxY = 0;\n        }\n\n        var padding = this.boundsPadding;\n\n        this._localBounds.minX = minX - padding;\n        this._localBounds.maxX = maxX + padding;\n\n        this._localBounds.minY = minY - padding;\n        this._localBounds.maxY = maxY + padding;\n    };\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @return {PIXI.GraphicsData} The generated GraphicsData object.\n     */\n\n\n    Graphics.prototype.drawShape = function drawShape(shape) {\n        if (this.currentPath) {\n            // check current path!\n            if (this.currentPath.shape.points.length <= 2) {\n                this.graphicsData.pop();\n            }\n        }\n\n        this.currentPath = null;\n\n        var data = new _GraphicsData2.default(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, this.nativeLines, shape);\n\n        this.graphicsData.push(data);\n\n        if (data.type === _const.SHAPES.POLY) {\n            data.shape.closed = data.shape.closed || this.filling;\n            this.currentPath = data;\n        }\n\n        this.dirty++;\n\n        return data;\n    };\n\n    /**\n     * Generates a canvas texture.\n     *\n     * @param {number} scaleMode - The scale mode of the texture.\n     * @param {number} resolution - The resolution of the texture.\n     * @return {PIXI.Texture} The new texture.\n     */\n\n\n    Graphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode) {\n        var resolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n        var bounds = this.getLocalBounds();\n\n        var canvasBuffer = _RenderTexture2.default.create(bounds.width, bounds.height, scaleMode, resolution);\n\n        if (!canvasRenderer) {\n            canvasRenderer = new _CanvasRenderer2.default();\n        }\n\n        this.transform.updateLocalTransform();\n        this.transform.localTransform.copy(tempMatrix);\n\n        tempMatrix.invert();\n\n        tempMatrix.tx -= bounds.x;\n        tempMatrix.ty -= bounds.y;\n\n        canvasRenderer.render(this, canvasBuffer, true, tempMatrix);\n\n        var texture = _Texture2.default.fromCanvas(canvasBuffer.baseTexture._canvasRenderTarget.canvas, scaleMode, 'graphics');\n\n        texture.baseTexture.resolution = resolution;\n        texture.baseTexture.update();\n\n        return texture;\n    };\n\n    /**\n     * Closes the current path.\n     *\n     * @return {PIXI.Graphics} Returns itself.\n     */\n\n\n    Graphics.prototype.closePath = function closePath() {\n        // ok so close path assumes next one is a hole!\n        var currentPath = this.currentPath;\n\n        if (currentPath && currentPath.shape) {\n            currentPath.shape.close();\n        }\n\n        return this;\n    };\n\n    /**\n     * Adds a hole in the current path.\n     *\n     * @return {PIXI.Graphics} Returns itself.\n     */\n\n\n    Graphics.prototype.addHole = function addHole() {\n        // this is a hole!\n        var hole = this.graphicsData.pop();\n\n        this.currentPath = this.graphicsData[this.graphicsData.length - 1];\n\n        this.currentPath.addHole(hole.shape);\n        this.currentPath = null;\n\n        return this;\n    };\n\n    /**\n     * Destroys the Graphics object.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n\n\n    Graphics.prototype.destroy = function destroy(options) {\n        _Container.prototype.destroy.call(this, options);\n\n        // destroy each of the GraphicsData objects\n        for (var i = 0; i < this.graphicsData.length; ++i) {\n            this.graphicsData[i].destroy();\n        }\n\n        // for each webgl data entry, destroy the WebGLGraphicsData\n        for (var id in this._webgl) {\n            for (var j = 0; j < this._webgl[id].data.length; ++j) {\n                this._webgl[id].data[j].destroy();\n            }\n        }\n\n        if (this._spriteRect) {\n            this._spriteRect.destroy();\n        }\n\n        this.graphicsData = null;\n\n        this.currentPath = null;\n        this._webgl = null;\n        this._localBounds = null;\n    };\n\n    return Graphics;\n}(_Container3.default);\n\nexports.default = Graphics;\n\n\nGraphics._SPRITE_TEXTURE = null;\n","map":{"version":3,"sources":["../../../src/core/graphics/Graphics.js"],"names":["canvasRenderer","tempMatrix","tempPoint","tempColor1","Float32Array","tempColor2","Graphics","nativeLines","fillAlpha","lineWidth","lineColor","graphicsData","tint","_prevTint","blendMode","NORMAL","currentPath","_webGL","isMask","boundsPadding","_localBounds","dirty","fastRectDirty","clearDirty","boundsDirty","cachedSpriteDirty","_spriteRect","_fastRect","clone","renderable","i","length","push","updateLocalBounds","lineStyle","color","alpha","lineAlpha","shape","points","slice","closed","drawShape","moveTo","x","y","lineTo","quadraticCurveTo","cpX","cpY","toX","toY","n","xa","ya","fromX","fromY","j","bezierCurveTo","cpX2","cpY2","arcTo","x1","y1","x2","y2","radius","a1","b1","a2","b2","mm","Math","abs","dd","cc","tt","k1","sqrt","k2","j1","j2","cx","cy","px","py","qx","qy","startAngle","atan2","endAngle","arc","anticlockwise","PI","sweep","segs","ceil","startX","cos","startY","sin","theta","theta2","cTheta","sTheta","segMinus","remainder","real","angle","c","s","beginFill","filling","fillColor","fill","endFill","drawRect","width","height","drawRoundedRect","drawCircle","drawEllipse","drawPolygon","path","Array","isArray","arguments","clear","isFastRect","type","RECT","_renderWebGL","renderer","_renderSpriteRect","setObjectRenderer","plugins","graphics","render","rect","WHITE","sprite","t1","t2","worldAlpha","_texture","_frame","transform","worldTransform","anchor","set","_onAnchorUpdate","_renderCanvas","_calculateBounds","lb","_bounds","addFrame","minX","minY","maxX","maxY","containsPoint","point","applyInverse","data","contains","holes","hole","Infinity","w","h","RREC","CIRC","ELIP","dx","dy","rw","rh","padding","pop","POLY","generateCanvasTexture","scaleMode","resolution","bounds","getLocalBounds","canvasBuffer","create","updateLocalTransform","localTransform","copy","invert","tx","ty","texture","fromCanvas","baseTexture","_canvasRenderTarget","canvas","update","closePath","close","addHole","destroy","options","id","_webgl","_SPRITE_TEXTURE"],"mappings":"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","file":"Graphics.js","sourcesContent":["import Container from '../display/Container';\nimport RenderTexture from '../textures/RenderTexture';\nimport Texture from '../textures/Texture';\nimport GraphicsData from './GraphicsData';\nimport Sprite from '../sprites/Sprite';\nimport { Matrix, Point, Rectangle, RoundedRectangle, Ellipse, Polygon, Circle } from '../math';\nimport { hex2rgb, rgb2hex } from '../utils';\nimport { SHAPES, BLEND_MODES } from '../const';\nimport Bounds from '../display/Bounds';\nimport bezierCurveTo from './utils/bezierCurveTo';\nimport CanvasRenderer from '../renderers/canvas/CanvasRenderer';\n\nlet canvasRenderer;\nconst tempMatrix = new Matrix();\nconst tempPoint = new Point();\nconst tempColor1 = new Float32Array(4);\nconst tempColor2 = new Float32Array(4);\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\nexport default class Graphics extends Container\n{\n    /**\n     *\n     * @param {boolean} [nativeLines=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     */\n    constructor(nativeLines = false)\n    {\n        super();\n\n        /**\n         * The alpha value used when filling the Graphics object.\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.fillAlpha = 1;\n\n        /**\n         * The width (thickness) of any lines drawn.\n         *\n         * @member {number}\n         * @default 0\n         */\n        this.lineWidth = 0;\n\n        /**\n         * If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n         *\n         * @member {boolean}\n         */\n        this.nativeLines = nativeLines;\n\n        /**\n         * The color of any lines drawn.\n         *\n         * @member {string}\n         * @default 0\n         */\n        this.lineColor = 0;\n\n        /**\n         * Graphics data\n         *\n         * @member {PIXI.GraphicsData[]}\n         * @private\n         */\n        this.graphicsData = [];\n\n        /**\n         * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to\n         * reset the tint.\n         *\n         * @member {number}\n         * @default 0xFFFFFF\n         */\n        this.tint = 0xFFFFFF;\n\n        /**\n         * The previous tint applied to the graphic shape. Used to compare to the current tint and\n         * check if theres change.\n         *\n         * @member {number}\n         * @private\n         * @default 0xFFFFFF\n         */\n        this._prevTint = 0xFFFFFF;\n\n        /**\n         * The blend mode to be applied to the graphic shape. Apply a value of\n         * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n         *\n         * @member {number}\n         * @default PIXI.BLEND_MODES.NORMAL;\n         * @see PIXI.BLEND_MODES\n         */\n        this.blendMode = BLEND_MODES.NORMAL;\n\n        /**\n         * Current path\n         *\n         * @member {PIXI.GraphicsData}\n         * @private\n         */\n        this.currentPath = null;\n\n        /**\n         * Array containing some WebGL-related properties used by the WebGL renderer.\n         *\n         * @member {object<number, object>}\n         * @private\n         */\n        // TODO - _webgl should use a prototype object, not a random undocumented object...\n        this._webGL = {};\n\n        /**\n         * Whether this shape is being used as a mask.\n         *\n         * @member {boolean}\n         */\n        this.isMask = false;\n\n        /**\n         * The bounds' padding used for bounds calculation.\n         *\n         * @member {number}\n         */\n        this.boundsPadding = 0;\n\n        /**\n         * A cache of the local bounds to prevent recalculation.\n         *\n         * @member {PIXI.Rectangle}\n         * @private\n         */\n        this._localBounds = new Bounds();\n\n        /**\n         * Used to detect if the graphics object has changed. If this is set to true then the graphics\n         * object will be recalculated.\n         *\n         * @member {boolean}\n         * @private\n         */\n        this.dirty = 0;\n\n        /**\n         * Used to detect if we need to do a fast rect check using the id compare method\n         * @type {Number}\n         */\n        this.fastRectDirty = -1;\n\n        /**\n         * Used to detect if we clear the graphics webGL data\n         * @type {Number}\n         */\n        this.clearDirty = 0;\n\n        /**\n         * Used to detect if we we need to recalculate local bounds\n         * @type {Number}\n         */\n        this.boundsDirty = -1;\n\n        /**\n         * Used to detect if the cached sprite object needs to be updated.\n         *\n         * @member {boolean}\n         * @private\n         */\n        this.cachedSpriteDirty = false;\n\n        this._spriteRect = null;\n        this._fastRect = false;\n\n        /**\n         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n         * This is useful if your graphics element does not change often, as it will speed up the rendering\n         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n         * you are constantly redrawing the graphics element.\n         *\n         * @name cacheAsBitmap\n         * @member {boolean}\n         * @memberof PIXI.Graphics#\n         * @default false\n         */\n    }\n\n    /**\n     * Creates a new Graphics object with the same values as this one.\n     * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)\n     *\n     * @return {PIXI.Graphics} A clone of the graphics object\n     */\n    clone()\n    {\n        const clone = new Graphics();\n\n        clone.renderable = this.renderable;\n        clone.fillAlpha = this.fillAlpha;\n        clone.lineWidth = this.lineWidth;\n        clone.lineColor = this.lineColor;\n        clone.tint = this.tint;\n        clone.blendMode = this.blendMode;\n        clone.isMask = this.isMask;\n        clone.boundsPadding = this.boundsPadding;\n        clone.dirty = 0;\n        clone.cachedSpriteDirty = this.cachedSpriteDirty;\n\n        // copy graphics data\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            clone.graphicsData.push(this.graphicsData[i].clone());\n        }\n\n        clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];\n\n        clone.updateLocalBounds();\n\n        return clone;\n    }\n\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     *\n     * @param {number} [lineWidth=0] - width of the line to draw, will update the objects stored style\n     * @param {number} [color=0] - color of the line to draw, will update the objects stored style\n     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    lineStyle(lineWidth = 0, color = 0, alpha = 1)\n    {\n        this.lineWidth = lineWidth;\n        this.lineColor = color;\n        this.lineAlpha = alpha;\n\n        if (this.currentPath)\n        {\n            if (this.currentPath.shape.points.length)\n            {\n                // halfway through a line? start a new one!\n                const shape = new Polygon(this.currentPath.shape.points.slice(-2));\n\n                shape.closed = false;\n\n                this.drawShape(shape);\n            }\n            else\n            {\n                // otherwise its empty so lets just set the line properties\n                this.currentPath.lineWidth = this.lineWidth;\n                this.currentPath.lineColor = this.lineColor;\n                this.currentPath.lineAlpha = this.lineAlpha;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Moves the current drawing position to x, y.\n     *\n     * @param {number} x - the X coordinate to move to\n     * @param {number} y - the Y coordinate to move to\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    moveTo(x, y)\n    {\n        const shape = new Polygon([x, y]);\n\n        shape.closed = false;\n        this.drawShape(shape);\n\n        return this;\n    }\n\n    /**\n     * Draws a line using the current line style from the current drawing position to (x, y);\n     * The current drawing position is then set to (x, y).\n     *\n     * @param {number} x - the X coordinate to draw to\n     * @param {number} y - the Y coordinate to draw to\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    lineTo(x, y)\n    {\n        this.currentPath.shape.points.push(x, y);\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     *\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    quadraticCurveTo(cpX, cpY, toX, toY)\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.shape.points.length === 0)\n            {\n                this.currentPath.shape.points = [0, 0];\n            }\n        }\n        else\n        {\n            this.moveTo(0, 0);\n        }\n\n        const n = 20;\n        const points = this.currentPath.shape.points;\n        let xa = 0;\n        let ya = 0;\n\n        if (points.length === 0)\n        {\n            this.moveTo(0, 0);\n        }\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        for (let i = 1; i <= n; ++i)\n        {\n            const j = i / n;\n\n            xa = fromX + ((cpX - fromX) * j);\n            ya = fromY + ((cpY - fromY) * j);\n\n            points.push(xa + (((cpX + ((toX - cpX) * j)) - xa) * j),\n                ya + (((cpY + ((toY - cpY) * j)) - ya) * j));\n        }\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY)\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.shape.points.length === 0)\n            {\n                this.currentPath.shape.points = [0, 0];\n            }\n        }\n        else\n        {\n            this.moveTo(0, 0);\n        }\n\n        const points = this.currentPath.shape.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        points.length -= 2;\n\n        bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, points);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     *\n     * @param {number} x1 - The x-coordinate of the beginning of the arc\n     * @param {number} y1 - The y-coordinate of the beginning of the arc\n     * @param {number} x2 - The x-coordinate of the end of the arc\n     * @param {number} y2 - The y-coordinate of the end of the arc\n     * @param {number} radius - The radius of the arc\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    arcTo(x1, y1, x2, y2, radius)\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.shape.points.length === 0)\n            {\n                this.currentPath.shape.points.push(x1, y1);\n            }\n        }\n        else\n        {\n            this.moveTo(x1, y1);\n        }\n\n        const points = this.currentPath.shape.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n        const a1 = fromY - y1;\n        const b1 = fromX - x1;\n        const a2 = y2 - y1;\n        const b2 = x2 - x1;\n        const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n        if (mm < 1.0e-8 || radius === 0)\n        {\n            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n            {\n                points.push(x1, y1);\n            }\n        }\n        else\n        {\n            const dd = (a1 * a1) + (b1 * b1);\n            const cc = (a2 * a2) + (b2 * b2);\n            const tt = (a1 * a2) + (b1 * b2);\n            const k1 = radius * Math.sqrt(dd) / mm;\n            const k2 = radius * Math.sqrt(cc) / mm;\n            const j1 = k1 * tt / dd;\n            const j2 = k2 * tt / cc;\n            const cx = (k1 * b2) + (k2 * b1);\n            const cy = (k1 * a2) + (k2 * a1);\n            const px = b1 * (k2 + j1);\n            const py = a1 * (k2 + j1);\n            const qx = b2 * (k1 + j2);\n            const qy = a2 * (k1 + j2);\n            const startAngle = Math.atan2(py - cy, px - cx);\n            const endAngle = Math.atan2(qy - cy, qx - cx);\n\n            this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);\n        }\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     *\n     * @param {number} cx - The x-coordinate of the center of the circle\n     * @param {number} cy - The y-coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param {number} endAngle - The ending angle, in radians\n     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false)\n    {\n        if (startAngle === endAngle)\n        {\n            return this;\n        }\n\n        if (!anticlockwise && endAngle <= startAngle)\n        {\n            endAngle += Math.PI * 2;\n        }\n        else if (anticlockwise && startAngle <= endAngle)\n        {\n            startAngle += Math.PI * 2;\n        }\n\n        const sweep = endAngle - startAngle;\n        const segs = Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 40;\n\n        if (sweep === 0)\n        {\n            return this;\n        }\n\n        const startX = cx + (Math.cos(startAngle) * radius);\n        const startY = cy + (Math.sin(startAngle) * radius);\n\n        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n        let points = this.currentPath ? this.currentPath.shape.points : null;\n\n        if (points)\n        {\n            if (points[points.length - 2] !== startX || points[points.length - 1] !== startY)\n            {\n                points.push(startX, startY);\n            }\n        }\n        else\n        {\n            this.moveTo(startX, startY);\n            points = this.currentPath.shape.points;\n        }\n\n        const theta = sweep / (segs * 2);\n        const theta2 = theta * 2;\n\n        const cTheta = Math.cos(theta);\n        const sTheta = Math.sin(theta);\n\n        const segMinus = segs - 1;\n\n        const remainder = (segMinus % 1) / segMinus;\n\n        for (let i = 0; i <= segMinus; ++i)\n        {\n            const real = i + (remainder * i);\n\n            const angle = ((theta) + startAngle + (theta2 * real));\n\n            const c = Math.cos(angle);\n            const s = -Math.sin(angle);\n\n            points.push(\n                (((cTheta * c) + (sTheta * s)) * radius) + cx,\n                (((cTheta * -s) + (sTheta * c)) * radius) + cy\n            );\n        }\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n     * (such as lineTo() or drawCircle()) use when drawing.\n     *\n     * @param {number} [color=0] - the color of the fill\n     * @param {number} [alpha=1] - the alpha of the fill\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    beginFill(color = 0, alpha = 1)\n    {\n        this.filling = true;\n        this.fillColor = color;\n        this.fillAlpha = alpha;\n\n        if (this.currentPath)\n        {\n            if (this.currentPath.shape.points.length <= 2)\n            {\n                this.currentPath.fill = this.filling;\n                this.currentPath.fillColor = this.fillColor;\n                this.currentPath.fillAlpha = this.fillAlpha;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n     *\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    endFill()\n    {\n        this.filling = false;\n        this.fillColor = null;\n        this.fillAlpha = 1;\n\n        return this;\n    }\n\n    /**\n     *\n     * @param {number} x - The X coord of the top-left of the rectangle\n     * @param {number} y - The Y coord of the top-left of the rectangle\n     * @param {number} width - The width of the rectangle\n     * @param {number} height - The height of the rectangle\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawRect(x, y, width, height)\n    {\n        this.drawShape(new Rectangle(x, y, width, height));\n\n        return this;\n    }\n\n    /**\n     *\n     * @param {number} x - The X coord of the top-left of the rectangle\n     * @param {number} y - The Y coord of the top-left of the rectangle\n     * @param {number} width - The width of the rectangle\n     * @param {number} height - The height of the rectangle\n     * @param {number} radius - Radius of the rectangle corners\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawRoundedRect(x, y, width, height, radius)\n    {\n        this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n\n        return this;\n    }\n\n    /**\n     * Draws a circle.\n     *\n     * @param {number} x - The X coordinate of the center of the circle\n     * @param {number} y - The Y coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawCircle(x, y, radius)\n    {\n        this.drawShape(new Circle(x, y, radius));\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse.\n     *\n     * @param {number} x - The X coordinate of the center of the ellipse\n     * @param {number} y - The Y coordinate of the center of the ellipse\n     * @param {number} width - The half width of the ellipse\n     * @param {number} height - The half height of the ellipse\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawEllipse(x, y, width, height)\n    {\n        this.drawShape(new Ellipse(x, y, width, height));\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon using the given path.\n     *\n     * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawPolygon(path)\n    {\n        // prevents an argument assignment deopt\n        // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n        let points = path;\n\n        let closed = true;\n\n        if (points instanceof Polygon)\n        {\n            closed = points.closed;\n            points = points.points;\n        }\n\n        if (!Array.isArray(points))\n        {\n            // prevents an argument leak deopt\n            // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n            points = new Array(arguments.length);\n\n            for (let i = 0; i < points.length; ++i)\n            {\n                points[i] = arguments[i]; // eslint-disable-line prefer-rest-params\n            }\n        }\n\n        const shape = new Polygon(points);\n\n        shape.closed = closed;\n\n        this.drawShape(shape);\n\n        return this;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     *\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    clear()\n    {\n        if (this.lineWidth || this.filling || this.graphicsData.length > 0)\n        {\n            this.lineWidth = 0;\n            this.filling = false;\n\n            this.boundsDirty = -1;\n            this.dirty++;\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        this.currentPath = null;\n        this._spriteRect = null;\n\n        return this;\n    }\n\n    /**\n     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n     * masked with gl.scissor.\n     *\n     * @returns {boolean} True if only 1 rect.\n     */\n    isFastRect()\n    {\n        return this.graphicsData.length === 1\n            && this.graphicsData[0].shape.type === SHAPES.RECT\n            && !this.graphicsData[0].lineWidth;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    _renderWebGL(renderer)\n    {\n        // if the sprite is not visible or the alpha is 0 then no need to render this element\n        if (this.dirty !== this.fastRectDirty)\n        {\n            this.fastRectDirty = this.dirty;\n            this._fastRect = this.isFastRect();\n        }\n\n        // TODO this check can be moved to dirty?\n        if (this._fastRect)\n        {\n            this._renderSpriteRect(renderer);\n        }\n        else\n        {\n            renderer.setObjectRenderer(renderer.plugins.graphics);\n            renderer.plugins.graphics.render(this);\n        }\n    }\n\n    /**\n     * Renders a sprite rectangle.\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    _renderSpriteRect(renderer)\n    {\n        const rect = this.graphicsData[0].shape;\n\n        if (!this._spriteRect)\n        {\n            this._spriteRect = new Sprite(new Texture(Texture.WHITE));\n        }\n\n        const sprite = this._spriteRect;\n\n        if (this.tint === 0xffffff)\n        {\n            sprite.tint = this.graphicsData[0].fillColor;\n        }\n        else\n        {\n            const t1 = tempColor1;\n            const t2 = tempColor2;\n\n            hex2rgb(this.graphicsData[0].fillColor, t1);\n            hex2rgb(this.tint, t2);\n\n            t1[0] *= t2[0];\n            t1[1] *= t2[1];\n            t1[2] *= t2[2];\n\n            sprite.tint = rgb2hex(t1);\n        }\n        sprite.alpha = this.graphicsData[0].fillAlpha;\n        sprite.worldAlpha = this.worldAlpha * sprite.alpha;\n        sprite.blendMode = this.blendMode;\n\n        sprite._texture._frame.width = rect.width;\n        sprite._texture._frame.height = rect.height;\n\n        sprite.transform.worldTransform = this.transform.worldTransform;\n\n        sprite.anchor.set(-rect.x / rect.width, -rect.y / rect.height);\n        sprite._onAnchorUpdate();\n\n        sprite._renderWebGL(renderer);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    _renderCanvas(renderer)\n    {\n        if (this.isMask === true)\n        {\n            return;\n        }\n\n        renderer.plugins.graphics.render(this);\n    }\n\n    /**\n     * Retrieves the bounds of the graphic shape as a rectangle object\n     *\n     * @private\n     */\n    _calculateBounds()\n    {\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.updateLocalBounds();\n\n            this.cachedSpriteDirty = true;\n        }\n\n        const lb = this._localBounds;\n\n        this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY);\n    }\n\n    /**\n     * Tests if a point is inside this graphics object\n     *\n     * @param {PIXI.Point} point - the point to test\n     * @return {boolean} the result of the test\n     */\n    containsPoint(point)\n    {\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fill)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.shape.contains(tempPoint.x, tempPoint.y))\n                {\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.contains(tempPoint.x, tempPoint.y))\n                            {\n                                return false;\n                            }\n                        }\n                    }\n\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Update the bounds of the object\n     *\n     */\n    updateLocalBounds()\n    {\n        let minX = Infinity;\n        let maxX = -Infinity;\n\n        let minY = Infinity;\n        let maxY = -Infinity;\n\n        if (this.graphicsData.length)\n        {\n            let shape = 0;\n            let x = 0;\n            let y = 0;\n            let w = 0;\n            let h = 0;\n\n            for (let i = 0; i < this.graphicsData.length; i++)\n            {\n                const data = this.graphicsData[i];\n                const type = data.type;\n                const lineWidth = data.lineWidth;\n\n                shape = data.shape;\n\n                if (type === SHAPES.RECT || type === SHAPES.RREC)\n                {\n                    x = shape.x - (lineWidth / 2);\n                    y = shape.y - (lineWidth / 2);\n                    w = shape.width + lineWidth;\n                    h = shape.height + lineWidth;\n\n                    minX = x < minX ? x : minX;\n                    maxX = x + w > maxX ? x + w : maxX;\n\n                    minY = y < minY ? y : minY;\n                    maxY = y + h > maxY ? y + h : maxY;\n                }\n                else if (type === SHAPES.CIRC)\n                {\n                    x = shape.x;\n                    y = shape.y;\n                    w = shape.radius + (lineWidth / 2);\n                    h = shape.radius + (lineWidth / 2);\n\n                    minX = x - w < minX ? x - w : minX;\n                    maxX = x + w > maxX ? x + w : maxX;\n\n                    minY = y - h < minY ? y - h : minY;\n                    maxY = y + h > maxY ? y + h : maxY;\n                }\n                else if (type === SHAPES.ELIP)\n                {\n                    x = shape.x;\n                    y = shape.y;\n                    w = shape.width + (lineWidth / 2);\n                    h = shape.height + (lineWidth / 2);\n\n                    minX = x - w < minX ? x - w : minX;\n                    maxX = x + w > maxX ? x + w : maxX;\n\n                    minY = y - h < minY ? y - h : minY;\n                    maxY = y + h > maxY ? y + h : maxY;\n                }\n                else\n                {\n                    // POLY\n                    const points = shape.points;\n                    let x2 = 0;\n                    let y2 = 0;\n                    let dx = 0;\n                    let dy = 0;\n                    let rw = 0;\n                    let rh = 0;\n                    let cx = 0;\n                    let cy = 0;\n\n                    for (let j = 0; j + 2 < points.length; j += 2)\n                    {\n                        x = points[j];\n                        y = points[j + 1];\n                        x2 = points[j + 2];\n                        y2 = points[j + 3];\n                        dx = Math.abs(x2 - x);\n                        dy = Math.abs(y2 - y);\n                        h = lineWidth;\n                        w = Math.sqrt((dx * dx) + (dy * dy));\n\n                        if (w < 1e-9)\n                        {\n                            continue;\n                        }\n\n                        rw = ((h / w * dy) + dx) / 2;\n                        rh = ((h / w * dx) + dy) / 2;\n                        cx = (x2 + x) / 2;\n                        cy = (y2 + y) / 2;\n\n                        minX = cx - rw < minX ? cx - rw : minX;\n                        maxX = cx + rw > maxX ? cx + rw : maxX;\n\n                        minY = cy - rh < minY ? cy - rh : minY;\n                        maxY = cy + rh > maxY ? cy + rh : maxY;\n                    }\n                }\n            }\n        }\n        else\n        {\n            minX = 0;\n            maxX = 0;\n            minY = 0;\n            maxY = 0;\n        }\n\n        const padding = this.boundsPadding;\n\n        this._localBounds.minX = minX - padding;\n        this._localBounds.maxX = maxX + padding;\n\n        this._localBounds.minY = minY - padding;\n        this._localBounds.maxY = maxY + padding;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @return {PIXI.GraphicsData} The generated GraphicsData object.\n     */\n    drawShape(shape)\n    {\n        if (this.currentPath)\n        {\n            // check current path!\n            if (this.currentPath.shape.points.length <= 2)\n            {\n                this.graphicsData.pop();\n            }\n        }\n\n        this.currentPath = null;\n\n        const data = new GraphicsData(\n            this.lineWidth,\n            this.lineColor,\n            this.lineAlpha,\n            this.fillColor,\n            this.fillAlpha,\n            this.filling,\n            this.nativeLines,\n            shape\n        );\n\n        this.graphicsData.push(data);\n\n        if (data.type === SHAPES.POLY)\n        {\n            data.shape.closed = data.shape.closed || this.filling;\n            this.currentPath = data;\n        }\n\n        this.dirty++;\n\n        return data;\n    }\n\n    /**\n     * Generates a canvas texture.\n     *\n     * @param {number} scaleMode - The scale mode of the texture.\n     * @param {number} resolution - The resolution of the texture.\n     * @return {PIXI.Texture} The new texture.\n     */\n    generateCanvasTexture(scaleMode, resolution = 1)\n    {\n        const bounds = this.getLocalBounds();\n\n        const canvasBuffer = RenderTexture.create(bounds.width, bounds.height, scaleMode, resolution);\n\n        if (!canvasRenderer)\n        {\n            canvasRenderer = new CanvasRenderer();\n        }\n\n        this.transform.updateLocalTransform();\n        this.transform.localTransform.copy(tempMatrix);\n\n        tempMatrix.invert();\n\n        tempMatrix.tx -= bounds.x;\n        tempMatrix.ty -= bounds.y;\n\n        canvasRenderer.render(this, canvasBuffer, true, tempMatrix);\n\n        const texture = Texture.fromCanvas(canvasBuffer.baseTexture._canvasRenderTarget.canvas, scaleMode, 'graphics');\n\n        texture.baseTexture.resolution = resolution;\n        texture.baseTexture.update();\n\n        return texture;\n    }\n\n    /**\n     * Closes the current path.\n     *\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    closePath()\n    {\n        // ok so close path assumes next one is a hole!\n        const currentPath = this.currentPath;\n\n        if (currentPath && currentPath.shape)\n        {\n            currentPath.shape.close();\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds a hole in the current path.\n     *\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    addHole()\n    {\n        // this is a hole!\n        const hole = this.graphicsData.pop();\n\n        this.currentPath = this.graphicsData[this.graphicsData.length - 1];\n\n        this.currentPath.addHole(hole.shape);\n        this.currentPath = null;\n\n        return this;\n    }\n\n    /**\n     * Destroys the Graphics object.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        super.destroy(options);\n\n        // destroy each of the GraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        // for each webgl data entry, destroy the WebGLGraphicsData\n        for (const id in this._webgl)\n        {\n            for (let j = 0; j < this._webgl[id].data.length; ++j)\n            {\n                this._webgl[id].data[j].destroy();\n            }\n        }\n\n        if (this._spriteRect)\n        {\n            this._spriteRect.destroy();\n        }\n\n        this.graphicsData = null;\n\n        this.currentPath = null;\n        this._webgl = null;\n        this._localBounds = null;\n    }\n\n}\n\nGraphics._SPRITE_TEXTURE = null;\n"]}},"hash":"efa2ddd91f4f8991659aa57d5f816300","cacheData":{"env":{}}}