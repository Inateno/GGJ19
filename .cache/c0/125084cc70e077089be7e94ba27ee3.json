{"id":"../node_modules/pixi.js/lib/extract/webgl/WebGLExtract.js","dependencies":[{"name":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/lib/extract/webgl/WebGLExtract.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/antoine/Documents/perso/gamedev/GGJ19/package.json","includedInParent":true,"mtime":1548542467768},{"name":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/package.json","includedInParent":true,"mtime":1548541995508},{"name":"../../core","loc":{"line":5,"column":20},"parent":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/lib/extract/webgl/WebGLExtract.js","resolved":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/lib/core/index.js"}],"generated":{"js":"'use strict';\n\nexports.__esModule = true;\n\nvar _core = require('../../core');\n\nvar core = _interopRequireWildcard(_core);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TEMP_RECT = new core.Rectangle();\nvar BYTES_PER_PIXEL = 4;\n\n/**\n * The extract manager provides functionality to export content from the renderers.\n *\n * An instance of this class is automatically created by default, and can be found at renderer.plugins.extract\n *\n * @class\n * @memberof PIXI.extract\n */\n\nvar WebGLExtract = function () {\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - A reference to the current renderer\n     */\n    function WebGLExtract(renderer) {\n        _classCallCheck(this, WebGLExtract);\n\n        this.renderer = renderer;\n        /**\n         * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture\n         *\n         * @member {PIXI.extract.WebGLExtract} extract\n         * @memberof PIXI.WebGLRenderer#\n         * @see PIXI.extract.WebGLExtract\n         */\n        renderer.extract = this;\n    }\n\n    /**\n     * Will return a HTML Image of the target\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {HTMLImageElement} HTML Image of the target\n     */\n\n\n    WebGLExtract.prototype.image = function image(target) {\n        var image = new Image();\n\n        image.src = this.base64(target);\n\n        return image;\n    };\n\n    /**\n     * Will return a a base64 encoded string of this target. It works by calling\n     *  `WebGLExtract.getCanvas` and then running toDataURL on that.\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {string} A base64 encoded string of the texture.\n     */\n\n\n    WebGLExtract.prototype.base64 = function base64(target) {\n        return this.canvas(target).toDataURL();\n    };\n\n    /**\n     * Creates a Canvas element, renders this target to it and then returns it.\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.\n     */\n\n\n    WebGLExtract.prototype.canvas = function canvas(target) {\n        var renderer = this.renderer;\n        var textureBuffer = void 0;\n        var resolution = void 0;\n        var frame = void 0;\n        var flipY = false;\n        var renderTexture = void 0;\n        var generated = false;\n\n        if (target) {\n            if (target instanceof core.RenderTexture) {\n                renderTexture = target;\n            } else {\n                renderTexture = this.renderer.generateTexture(target);\n                generated = true;\n            }\n        }\n\n        if (renderTexture) {\n            textureBuffer = renderTexture.baseTexture._glRenderTargets[this.renderer.CONTEXT_UID];\n            resolution = textureBuffer.resolution;\n            frame = renderTexture.frame;\n            flipY = false;\n        } else {\n            textureBuffer = this.renderer.rootRenderTarget;\n            resolution = textureBuffer.resolution;\n            flipY = true;\n\n            frame = TEMP_RECT;\n            frame.width = textureBuffer.size.width;\n            frame.height = textureBuffer.size.height;\n        }\n\n        var width = frame.width * resolution;\n        var height = frame.height * resolution;\n\n        var canvasBuffer = new core.CanvasRenderTarget(width, height, 1);\n\n        if (textureBuffer) {\n            // bind the buffer\n            renderer.bindRenderTarget(textureBuffer);\n\n            // set up an array of pixels\n            var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n            // read pixels to the array\n            var gl = renderer.gl;\n\n            gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);\n\n            // add the pixels to the canvas\n            var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);\n\n            canvasData.data.set(webglPixels);\n\n            canvasBuffer.context.putImageData(canvasData, 0, 0);\n\n            // pulling pixels\n            if (flipY) {\n                canvasBuffer.context.scale(1, -1);\n                canvasBuffer.context.drawImage(canvasBuffer.canvas, 0, -height);\n            }\n        }\n\n        if (generated) {\n            renderTexture.destroy(true);\n        }\n        // send the canvas back..\n\n        return canvasBuffer.canvas;\n    };\n\n    /**\n     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n     * order, with integer values between 0 and 255 (included).\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {Uint8ClampedArray} One-dimensional array containing the pixel data of the entire texture\n     */\n\n\n    WebGLExtract.prototype.pixels = function pixels(target) {\n        var renderer = this.renderer;\n        var textureBuffer = void 0;\n        var resolution = void 0;\n        var frame = void 0;\n        var renderTexture = void 0;\n        var generated = false;\n\n        if (target) {\n            if (target instanceof core.RenderTexture) {\n                renderTexture = target;\n            } else {\n                renderTexture = this.renderer.generateTexture(target);\n                generated = true;\n            }\n        }\n\n        if (renderTexture) {\n            textureBuffer = renderTexture.baseTexture._glRenderTargets[this.renderer.CONTEXT_UID];\n            resolution = textureBuffer.resolution;\n            frame = renderTexture.frame;\n        } else {\n            textureBuffer = this.renderer.rootRenderTarget;\n            resolution = textureBuffer.resolution;\n\n            frame = TEMP_RECT;\n            frame.width = textureBuffer.size.width;\n            frame.height = textureBuffer.size.height;\n        }\n\n        var width = frame.width * resolution;\n        var height = frame.height * resolution;\n\n        var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n        if (textureBuffer) {\n            // bind the buffer\n            renderer.bindRenderTarget(textureBuffer);\n            // read pixels to the array\n            var gl = renderer.gl;\n\n            gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);\n        }\n\n        if (generated) {\n            renderTexture.destroy(true);\n        }\n\n        return webglPixels;\n    };\n\n    /**\n     * Destroys the extract\n     *\n     */\n\n\n    WebGLExtract.prototype.destroy = function destroy() {\n        this.renderer.extract = null;\n        this.renderer = null;\n    };\n\n    return WebGLExtract;\n}();\n\nexports.default = WebGLExtract;\n\n\ncore.WebGLRenderer.registerPlugin('extract', WebGLExtract);\n","map":{"version":3,"sources":["../../../src/extract/webgl/WebGLExtract.js"],"names":["core","TEMP_RECT","Rectangle","BYTES_PER_PIXEL","WebGLExtract","renderer","extract","image","target","Image","src","base64","canvas","toDataURL","textureBuffer","resolution","frame","flipY","renderTexture","generated","RenderTexture","generateTexture","baseTexture","_glRenderTargets","CONTEXT_UID","rootRenderTarget","width","size","height","canvasBuffer","CanvasRenderTarget","bindRenderTarget","webglPixels","Uint8Array","gl","readPixels","x","y","RGBA","UNSIGNED_BYTE","canvasData","context","getImageData","data","set","putImageData","scale","drawImage","destroy","pixels","WebGLRenderer","registerPlugin"],"mappings":"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","file":"WebGLExtract.js","sourcesContent":["import * as core from '../../core';\n\nconst TEMP_RECT = new core.Rectangle();\nconst BYTES_PER_PIXEL = 4;\n\n/**\n * The extract manager provides functionality to export content from the renderers.\n *\n * An instance of this class is automatically created by default, and can be found at renderer.plugins.extract\n *\n * @class\n * @memberof PIXI.extract\n */\nexport default class WebGLExtract\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        this.renderer = renderer;\n        /**\n         * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture\n         *\n         * @member {PIXI.extract.WebGLExtract} extract\n         * @memberof PIXI.WebGLRenderer#\n         * @see PIXI.extract.WebGLExtract\n         */\n        renderer.extract = this;\n    }\n\n    /**\n     * Will return a HTML Image of the target\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {HTMLImageElement} HTML Image of the target\n     */\n    image(target)\n    {\n        const image = new Image();\n\n        image.src = this.base64(target);\n\n        return image;\n    }\n\n    /**\n     * Will return a a base64 encoded string of this target. It works by calling\n     *  `WebGLExtract.getCanvas` and then running toDataURL on that.\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {string} A base64 encoded string of the texture.\n     */\n    base64(target)\n    {\n        return this.canvas(target).toDataURL();\n    }\n\n    /**\n     * Creates a Canvas element, renders this target to it and then returns it.\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.\n     */\n    canvas(target)\n    {\n        const renderer = this.renderer;\n        let textureBuffer;\n        let resolution;\n        let frame;\n        let flipY = false;\n        let renderTexture;\n        let generated = false;\n\n        if (target)\n        {\n            if (target instanceof core.RenderTexture)\n            {\n                renderTexture = target;\n            }\n            else\n            {\n                renderTexture = this.renderer.generateTexture(target);\n                generated = true;\n            }\n        }\n\n        if (renderTexture)\n        {\n            textureBuffer = renderTexture.baseTexture._glRenderTargets[this.renderer.CONTEXT_UID];\n            resolution = textureBuffer.resolution;\n            frame = renderTexture.frame;\n            flipY = false;\n        }\n        else\n        {\n            textureBuffer = this.renderer.rootRenderTarget;\n            resolution = textureBuffer.resolution;\n            flipY = true;\n\n            frame = TEMP_RECT;\n            frame.width = textureBuffer.size.width;\n            frame.height = textureBuffer.size.height;\n        }\n\n        const width = frame.width * resolution;\n        const height = frame.height * resolution;\n\n        const canvasBuffer = new core.CanvasRenderTarget(width, height, 1);\n\n        if (textureBuffer)\n        {\n            // bind the buffer\n            renderer.bindRenderTarget(textureBuffer);\n\n            // set up an array of pixels\n            const webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n            // read pixels to the array\n            const gl = renderer.gl;\n\n            gl.readPixels(\n                frame.x * resolution,\n                frame.y * resolution,\n                width,\n                height,\n                gl.RGBA,\n                gl.UNSIGNED_BYTE,\n                webglPixels\n            );\n\n            // add the pixels to the canvas\n            const canvasData = canvasBuffer.context.getImageData(0, 0, width, height);\n\n            canvasData.data.set(webglPixels);\n\n            canvasBuffer.context.putImageData(canvasData, 0, 0);\n\n            // pulling pixels\n            if (flipY)\n            {\n                canvasBuffer.context.scale(1, -1);\n                canvasBuffer.context.drawImage(canvasBuffer.canvas, 0, -height);\n            }\n        }\n\n        if (generated)\n        {\n            renderTexture.destroy(true);\n        }\n        // send the canvas back..\n\n        return canvasBuffer.canvas;\n    }\n\n    /**\n     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n     * order, with integer values between 0 and 255 (included).\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {Uint8ClampedArray} One-dimensional array containing the pixel data of the entire texture\n     */\n    pixels(target)\n    {\n        const renderer = this.renderer;\n        let textureBuffer;\n        let resolution;\n        let frame;\n        let renderTexture;\n        let generated = false;\n\n        if (target)\n        {\n            if (target instanceof core.RenderTexture)\n            {\n                renderTexture = target;\n            }\n            else\n            {\n                renderTexture = this.renderer.generateTexture(target);\n                generated = true;\n            }\n        }\n\n        if (renderTexture)\n        {\n            textureBuffer = renderTexture.baseTexture._glRenderTargets[this.renderer.CONTEXT_UID];\n            resolution = textureBuffer.resolution;\n            frame = renderTexture.frame;\n        }\n        else\n        {\n            textureBuffer = this.renderer.rootRenderTarget;\n            resolution = textureBuffer.resolution;\n\n            frame = TEMP_RECT;\n            frame.width = textureBuffer.size.width;\n            frame.height = textureBuffer.size.height;\n        }\n\n        const width = frame.width * resolution;\n        const height = frame.height * resolution;\n\n        const webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n        if (textureBuffer)\n        {\n            // bind the buffer\n            renderer.bindRenderTarget(textureBuffer);\n            // read pixels to the array\n            const gl = renderer.gl;\n\n            gl.readPixels(\n                frame.x * resolution,\n                frame.y * resolution,\n                width,\n                height,\n                gl.RGBA,\n                gl.UNSIGNED_BYTE,\n                webglPixels\n            );\n        }\n\n        if (generated)\n        {\n            renderTexture.destroy(true);\n        }\n\n        return webglPixels;\n    }\n\n    /**\n     * Destroys the extract\n     *\n     */\n    destroy()\n    {\n        this.renderer.extract = null;\n        this.renderer = null;\n    }\n}\n\ncore.WebGLRenderer.registerPlugin('extract', WebGLExtract);\n"]}},"hash":"3ed77a9bd696f544e919998ba06b5bb9","cacheData":{"env":{}}}