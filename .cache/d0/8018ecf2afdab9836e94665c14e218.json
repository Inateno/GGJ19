{"id":"../node_modules/pixi.js/lib/extras/TextureTransform.js","dependencies":[{"name":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/lib/extras/TextureTransform.js.map","includedInParent":true,"mtime":1505920123000},{"name":"/Users/antoine/Documents/perso/gamedev/GGJ19/package.json","includedInParent":true,"mtime":1548528750924},{"name":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/package.json","includedInParent":true,"mtime":1548520101032},{"name":"../core/math/Matrix","loc":{"line":7,"column":22},"parent":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/lib/extras/TextureTransform.js","resolved":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/lib/core/math/Matrix.js"}],"generated":{"js":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Matrix = require('../core/math/Matrix');\n\nvar _Matrix2 = _interopRequireDefault(_Matrix);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar tempMat = new _Matrix2.default();\n\n/**\n * class controls uv transform and frame clamp for texture\n *\n * @class\n * @memberof PIXI.extras\n */\n\nvar TextureTransform = function () {\n    /**\n     *\n     * @param {PIXI.Texture} texture observed texture\n     * @param {number} [clampMargin] Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n     * @constructor\n     */\n    function TextureTransform(texture, clampMargin) {\n        _classCallCheck(this, TextureTransform);\n\n        this._texture = texture;\n\n        this.mapCoord = new _Matrix2.default();\n\n        this.uClampFrame = new Float32Array(4);\n\n        this.uClampOffset = new Float32Array(2);\n\n        this._lastTextureID = -1;\n\n        /**\n         * Changes frame clamping\n         * Works with TilingSprite and Mesh\n         * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders\n         *\n         * @default 0\n         * @member {number}\n         */\n        this.clampOffset = 0;\n\n        /**\n         * Changes frame clamping\n         * Works with TilingSprite and Mesh\n         * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n         *\n         * @default 0.5\n         * @member {number}\n         */\n        this.clampMargin = typeof clampMargin === 'undefined' ? 0.5 : clampMargin;\n    }\n\n    /**\n     * texture property\n     * @member {PIXI.Texture}\n     */\n\n\n    /**\n     * Multiplies uvs array to transform\n     * @param {Float32Array} uvs mesh uvs\n     * @param {Float32Array} [out=uvs] output\n     * @returns {Float32Array} output\n     */\n    TextureTransform.prototype.multiplyUvs = function multiplyUvs(uvs, out) {\n        if (out === undefined) {\n            out = uvs;\n        }\n\n        var mat = this.mapCoord;\n\n        for (var i = 0; i < uvs.length; i += 2) {\n            var x = uvs[i];\n            var y = uvs[i + 1];\n\n            out[i] = x * mat.a + y * mat.c + mat.tx;\n            out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n        }\n\n        return out;\n    };\n\n    /**\n     * updates matrices if texture was changed\n     * @param {boolean} forceUpdate if true, matrices will be updated any case\n     * @returns {boolean} whether or not it was updated\n     */\n\n\n    TextureTransform.prototype.update = function update(forceUpdate) {\n        var tex = this._texture;\n\n        if (!tex || !tex.valid) {\n            return false;\n        }\n\n        if (!forceUpdate && this._lastTextureID === tex._updateID) {\n            return false;\n        }\n\n        this._lastTextureID = tex._updateID;\n\n        var uvs = tex._uvs;\n\n        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n\n        var orig = tex.orig;\n        var trim = tex.trim;\n\n        if (trim) {\n            tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);\n            this.mapCoord.append(tempMat);\n        }\n\n        var texBase = tex.baseTexture;\n        var frame = this.uClampFrame;\n        var margin = this.clampMargin / texBase.resolution;\n        var offset = this.clampOffset;\n\n        frame[0] = (tex._frame.x + margin + offset) / texBase.width;\n        frame[1] = (tex._frame.y + margin + offset) / texBase.height;\n        frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;\n        frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;\n        this.uClampOffset[0] = offset / texBase.realWidth;\n        this.uClampOffset[1] = offset / texBase.realHeight;\n\n        return true;\n    };\n\n    _createClass(TextureTransform, [{\n        key: 'texture',\n        get: function get() {\n            return this._texture;\n        },\n        set: function set(value) // eslint-disable-line require-jsdoc\n        {\n            this._texture = value;\n            this._lastTextureID = -1;\n        }\n    }]);\n\n    return TextureTransform;\n}();\n\nexports.default = TextureTransform;\n","map":{"version":3,"sources":["../../src/extras/TextureTransform.js"],"names":["tempMat","TextureTransform","texture","clampMargin","_texture","mapCoord","uClampFrame","Float32Array","uClampOffset","_lastTextureID","clampOffset","multiplyUvs","uvs","out","undefined","mat","i","length","x","y","a","c","tx","b","d","ty","update","forceUpdate","tex","valid","_updateID","_uvs","set","x1","x0","y1","y0","x3","y3","orig","trim","width","height","append","texBase","baseTexture","frame","margin","resolution","offset","_frame","realWidth","realHeight","value"],"mappings":"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","file":"TextureTransform.js","sourcesContent":["import { default as Matrix } from '../core/math/Matrix';\n\nconst tempMat = new Matrix();\n\n/**\n * class controls uv transform and frame clamp for texture\n *\n * @class\n * @memberof PIXI.extras\n */\nexport default class TextureTransform\n{\n    /**\n     *\n     * @param {PIXI.Texture} texture observed texture\n     * @param {number} [clampMargin] Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n     * @constructor\n     */\n    constructor(texture, clampMargin)\n    {\n        this._texture = texture;\n\n        this.mapCoord = new Matrix();\n\n        this.uClampFrame = new Float32Array(4);\n\n        this.uClampOffset = new Float32Array(2);\n\n        this._lastTextureID = -1;\n\n        /**\n         * Changes frame clamping\n         * Works with TilingSprite and Mesh\n         * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders\n         *\n         * @default 0\n         * @member {number}\n         */\n        this.clampOffset = 0;\n\n        /**\n         * Changes frame clamping\n         * Works with TilingSprite and Mesh\n         * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n         *\n         * @default 0.5\n         * @member {number}\n         */\n        this.clampMargin = (typeof clampMargin === 'undefined') ? 0.5 : clampMargin;\n    }\n\n    /**\n     * texture property\n     * @member {PIXI.Texture}\n     */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    set texture(value) // eslint-disable-line require-jsdoc\n    {\n        this._texture = value;\n        this._lastTextureID = -1;\n    }\n\n    /**\n     * Multiplies uvs array to transform\n     * @param {Float32Array} uvs mesh uvs\n     * @param {Float32Array} [out=uvs] output\n     * @returns {Float32Array} output\n     */\n    multiplyUvs(uvs, out)\n    {\n        if (out === undefined)\n        {\n            out = uvs;\n        }\n\n        const mat = this.mapCoord;\n\n        for (let i = 0; i < uvs.length; i += 2)\n        {\n            const x = uvs[i];\n            const y = uvs[i + 1];\n\n            out[i] = (x * mat.a) + (y * mat.c) + mat.tx;\n            out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;\n        }\n\n        return out;\n    }\n\n    /**\n     * updates matrices if texture was changed\n     * @param {boolean} forceUpdate if true, matrices will be updated any case\n     * @returns {boolean} whether or not it was updated\n     */\n    update(forceUpdate)\n    {\n        const tex = this._texture;\n\n        if (!tex || !tex.valid)\n        {\n            return false;\n        }\n\n        if (!forceUpdate\n            && this._lastTextureID === tex._updateID)\n        {\n            return false;\n        }\n\n        this._lastTextureID = tex._updateID;\n\n        const uvs = tex._uvs;\n\n        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n\n        const orig = tex.orig;\n        const trim = tex.trim;\n\n        if (trim)\n        {\n            tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height,\n                -trim.x / trim.width, -trim.y / trim.height);\n            this.mapCoord.append(tempMat);\n        }\n\n        const texBase = tex.baseTexture;\n        const frame = this.uClampFrame;\n        const margin = this.clampMargin / texBase.resolution;\n        const offset = this.clampOffset;\n\n        frame[0] = (tex._frame.x + margin + offset) / texBase.width;\n        frame[1] = (tex._frame.y + margin + offset) / texBase.height;\n        frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;\n        frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;\n        this.uClampOffset[0] = offset / texBase.realWidth;\n        this.uClampOffset[1] = offset / texBase.realHeight;\n\n        return true;\n    }\n}\n"]}},"hash":"83390082196b59cadb5f2b2a7dbcb3d0","cacheData":{"env":{}}}