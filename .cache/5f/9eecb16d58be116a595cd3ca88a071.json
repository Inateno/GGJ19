{"id":"../node_modules/pixi.js/lib/mesh/webgl/MeshRenderer.js","dependencies":[{"name":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/lib/mesh/webgl/MeshRenderer.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/antoine/Documents/perso/gamedev/GGJ19/package.json","includedInParent":true,"mtime":1548542467768},{"name":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/package.json","includedInParent":true,"mtime":1548541995508},{"name":"../../core","loc":{"line":5,"column":20},"parent":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/lib/mesh/webgl/MeshRenderer.js","resolved":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/lib/core/index.js"},{"name":"pixi-gl-core","loc":{"line":9,"column":26},"parent":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/lib/mesh/webgl/MeshRenderer.js","resolved":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi-gl-core/src/index.js"},{"name":"../Mesh","loc":{"line":13,"column":20},"parent":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/lib/mesh/webgl/MeshRenderer.js","resolved":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/lib/mesh/Mesh.js"},{"name":"path","loc":{"line":17,"column":20},"parent":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/lib/mesh/webgl/MeshRenderer.js","resolved":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/path-browserify/index.js"}],"generated":{"js":"'use strict';\n\nexports.__esModule = true;\n\nvar _core = require('../../core');\n\nvar core = _interopRequireWildcard(_core);\n\nvar _pixiGlCore = require('pixi-gl-core');\n\nvar _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);\n\nvar _Mesh = require('../Mesh');\n\nvar _Mesh2 = _interopRequireDefault(_Mesh);\n\nvar _path = require('path');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar matrixIdentity = core.Matrix.IDENTITY;\n\n/**\n * WebGL renderer plugin for tiling sprites\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\n\nvar MeshRenderer = function (_core$ObjectRenderer) {\n    _inherits(MeshRenderer, _core$ObjectRenderer);\n\n    /**\n     * constructor for renderer\n     *\n     * @param {WebGLRenderer} renderer The renderer this tiling awesomeness works for.\n     */\n    function MeshRenderer(renderer) {\n        _classCallCheck(this, MeshRenderer);\n\n        var _this = _possibleConstructorReturn(this, _core$ObjectRenderer.call(this, renderer));\n\n        _this.shader = null;\n        return _this;\n    }\n\n    /**\n     * Sets up the renderer context and necessary buffers.\n     *\n     * @private\n     */\n\n\n    MeshRenderer.prototype.onContextChange = function onContextChange() {\n        var gl = this.renderer.gl;\n\n        this.shader = new core.Shader(gl, 'attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n', 'varying vec2 vTextureCoord;\\nuniform vec4 uColor;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void)\\n{\\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\\n}\\n');\n    };\n\n    /**\n     * renders mesh\n     *\n     * @param {PIXI.mesh.Mesh} mesh mesh instance\n     */\n\n\n    MeshRenderer.prototype.render = function render(mesh) {\n        var renderer = this.renderer;\n        var gl = renderer.gl;\n        var texture = mesh._texture;\n\n        if (!texture.valid) {\n            return;\n        }\n\n        var glData = mesh._glDatas[renderer.CONTEXT_UID];\n\n        if (!glData) {\n            renderer.bindVao(null);\n\n            glData = {\n                shader: this.shader,\n                vertexBuffer: _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, mesh.vertices, gl.STREAM_DRAW),\n                uvBuffer: _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, mesh.uvs, gl.STREAM_DRAW),\n                indexBuffer: _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, mesh.indices, gl.STATIC_DRAW),\n                // build the vao object that will render..\n                vao: null,\n                dirty: mesh.dirty,\n                indexDirty: mesh.indexDirty,\n                vertexDirty: mesh.vertexDirty\n            };\n\n            // build the vao object that will render..\n            glData.vao = new _pixiGlCore2.default.VertexArrayObject(gl).addIndex(glData.indexBuffer).addAttribute(glData.vertexBuffer, glData.shader.attributes.aVertexPosition, gl.FLOAT, false, 2 * 4, 0).addAttribute(glData.uvBuffer, glData.shader.attributes.aTextureCoord, gl.FLOAT, false, 2 * 4, 0);\n\n            mesh._glDatas[renderer.CONTEXT_UID] = glData;\n        }\n\n        renderer.bindVao(glData.vao);\n\n        if (mesh.dirty !== glData.dirty) {\n            glData.dirty = mesh.dirty;\n            glData.uvBuffer.upload(mesh.uvs);\n        }\n\n        if (mesh.indexDirty !== glData.indexDirty) {\n            glData.indexDirty = mesh.indexDirty;\n            glData.indexBuffer.upload(mesh.indices);\n        }\n\n        if (mesh.vertexDirty !== glData.vertexDirty) {\n            glData.vertexDirty = mesh.vertexDirty;\n            glData.vertexBuffer.upload(mesh.vertices);\n        }\n\n        renderer.bindShader(glData.shader);\n\n        glData.shader.uniforms.uSampler = renderer.bindTexture(texture);\n\n        renderer.state.setBlendMode(core.utils.correctBlendMode(mesh.blendMode, texture.baseTexture.premultipliedAlpha));\n\n        if (glData.shader.uniforms.uTransform) {\n            if (mesh.uploadUvTransform) {\n                glData.shader.uniforms.uTransform = mesh._uvTransform.mapCoord.toArray(true);\n            } else {\n                glData.shader.uniforms.uTransform = matrixIdentity.toArray(true);\n            }\n        }\n        glData.shader.uniforms.translationMatrix = mesh.worldTransform.toArray(true);\n\n        glData.shader.uniforms.uColor = core.utils.premultiplyRgba(mesh.tintRgb, mesh.worldAlpha, glData.shader.uniforms.uColor, texture.baseTexture.premultipliedAlpha);\n\n        var drawMode = mesh.drawMode === _Mesh2.default.DRAW_MODES.TRIANGLE_MESH ? gl.TRIANGLE_STRIP : gl.TRIANGLES;\n\n        glData.vao.draw(drawMode, mesh.indices.length, 0);\n    };\n\n    return MeshRenderer;\n}(core.ObjectRenderer);\n\nexports.default = MeshRenderer;\n\n\ncore.WebGLRenderer.registerPlugin('mesh', MeshRenderer);\n","map":{"version":3,"sources":["../../../src/mesh/webgl/MeshRenderer.js"],"names":["core","matrixIdentity","Matrix","IDENTITY","MeshRenderer","renderer","shader","onContextChange","gl","Shader","render","mesh","texture","_texture","valid","glData","_glDatas","CONTEXT_UID","bindVao","vertexBuffer","GLBuffer","createVertexBuffer","vertices","STREAM_DRAW","uvBuffer","uvs","indexBuffer","createIndexBuffer","indices","STATIC_DRAW","vao","dirty","indexDirty","vertexDirty","VertexArrayObject","addIndex","addAttribute","attributes","aVertexPosition","FLOAT","aTextureCoord","upload","bindShader","uniforms","uSampler","bindTexture","state","setBlendMode","utils","correctBlendMode","blendMode","baseTexture","premultipliedAlpha","uTransform","uploadUvTransform","_uvTransform","mapCoord","toArray","translationMatrix","worldTransform","uColor","premultiplyRgba","tintRgb","worldAlpha","drawMode","DRAW_MODES","TRIANGLE_MESH","TRIANGLE_STRIP","TRIANGLES","draw","length","ObjectRenderer","WebGLRenderer","registerPlugin"],"mappings":"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","file":"MeshRenderer.js","sourcesContent":["import * as core from '../../core';\nimport glCore from 'pixi-gl-core';\nimport { default as Mesh } from '../Mesh';\nimport { readFileSync } from 'fs';\nimport { join } from 'path';\n\nconst matrixIdentity = core.Matrix.IDENTITY;\n\n/**\n * WebGL renderer plugin for tiling sprites\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nexport default class MeshRenderer extends core.ObjectRenderer\n{\n\n    /**\n     * constructor for renderer\n     *\n     * @param {WebGLRenderer} renderer The renderer this tiling awesomeness works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        this.shader = null;\n    }\n\n    /**\n     * Sets up the renderer context and necessary buffers.\n     *\n     * @private\n     */\n    onContextChange()\n    {\n        const gl = this.renderer.gl;\n\n        this.shader = new core.Shader(gl,\n            readFileSync(join(__dirname, './mesh.vert'), 'utf8'),\n            readFileSync(join(__dirname, './mesh.frag'), 'utf8'));\n    }\n\n    /**\n     * renders mesh\n     *\n     * @param {PIXI.mesh.Mesh} mesh mesh instance\n     */\n    render(mesh)\n    {\n        const renderer = this.renderer;\n        const gl = renderer.gl;\n        const texture = mesh._texture;\n\n        if (!texture.valid)\n        {\n            return;\n        }\n\n        let glData = mesh._glDatas[renderer.CONTEXT_UID];\n\n        if (!glData)\n        {\n            renderer.bindVao(null);\n\n            glData = {\n                shader: this.shader,\n                vertexBuffer: glCore.GLBuffer.createVertexBuffer(gl, mesh.vertices, gl.STREAM_DRAW),\n                uvBuffer: glCore.GLBuffer.createVertexBuffer(gl, mesh.uvs, gl.STREAM_DRAW),\n                indexBuffer: glCore.GLBuffer.createIndexBuffer(gl, mesh.indices, gl.STATIC_DRAW),\n                // build the vao object that will render..\n                vao: null,\n                dirty: mesh.dirty,\n                indexDirty: mesh.indexDirty,\n                vertexDirty: mesh.vertexDirty,\n            };\n\n            // build the vao object that will render..\n            glData.vao = new glCore.VertexArrayObject(gl)\n                .addIndex(glData.indexBuffer)\n                .addAttribute(glData.vertexBuffer, glData.shader.attributes.aVertexPosition, gl.FLOAT, false, 2 * 4, 0)\n                .addAttribute(glData.uvBuffer, glData.shader.attributes.aTextureCoord, gl.FLOAT, false, 2 * 4, 0);\n\n            mesh._glDatas[renderer.CONTEXT_UID] = glData;\n        }\n\n        renderer.bindVao(glData.vao);\n\n        if (mesh.dirty !== glData.dirty)\n        {\n            glData.dirty = mesh.dirty;\n            glData.uvBuffer.upload(mesh.uvs);\n        }\n\n        if (mesh.indexDirty !== glData.indexDirty)\n        {\n            glData.indexDirty = mesh.indexDirty;\n            glData.indexBuffer.upload(mesh.indices);\n        }\n\n        if (mesh.vertexDirty !== glData.vertexDirty)\n        {\n            glData.vertexDirty = mesh.vertexDirty;\n            glData.vertexBuffer.upload(mesh.vertices);\n        }\n\n        renderer.bindShader(glData.shader);\n\n        glData.shader.uniforms.uSampler = renderer.bindTexture(texture);\n\n        renderer.state.setBlendMode(core.utils.correctBlendMode(mesh.blendMode, texture.baseTexture.premultipliedAlpha));\n\n        if (glData.shader.uniforms.uTransform)\n        {\n            if (mesh.uploadUvTransform)\n            {\n                glData.shader.uniforms.uTransform = mesh._uvTransform.mapCoord.toArray(true);\n            }\n            else\n            {\n                glData.shader.uniforms.uTransform = matrixIdentity.toArray(true);\n            }\n        }\n        glData.shader.uniforms.translationMatrix = mesh.worldTransform.toArray(true);\n\n        glData.shader.uniforms.uColor = core.utils.premultiplyRgba(mesh.tintRgb,\n            mesh.worldAlpha, glData.shader.uniforms.uColor, texture.baseTexture.premultipliedAlpha);\n\n        const drawMode = mesh.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH ? gl.TRIANGLE_STRIP : gl.TRIANGLES;\n\n        glData.vao.draw(drawMode, mesh.indices.length, 0);\n    }\n}\n\ncore.WebGLRenderer.registerPlugin('mesh', MeshRenderer);\n"]}},"hash":"7cb63b060e71ffb2141a60e00fa66fd7","cacheData":{"env":{}}}