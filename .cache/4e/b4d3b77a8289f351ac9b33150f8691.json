{"id":"../node_modules/pixi.js/lib/core/ticker/TickerListener.js","dependencies":[{"name":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/lib/core/ticker/TickerListener.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/antoine/Documents/perso/gamedev/GGJ19/package.json","includedInParent":true,"mtime":1548542467768},{"name":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/package.json","includedInParent":true,"mtime":1548541995508}],"generated":{"js":"\"use strict\";\n\nexports.__esModule = true;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Internal class for handling the priority sorting of ticker handlers.\n *\n * @private\n * @class\n * @memberof PIXI.ticker\n */\nvar TickerListener = function () {\n    /**\n     * Constructor\n     *\n     * @param {Function} fn - The listener function to be added for one update\n     * @param {Function} [context=null] - The listener context\n     * @param {number} [priority=0] - The priority for emitting\n     * @param {boolean} [once=false] - If the handler should fire once\n     */\n    function TickerListener(fn) {\n        var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        _classCallCheck(this, TickerListener);\n\n        /**\n         * The handler function to execute.\n         * @member {Function}\n         */\n        this.fn = fn;\n\n        /**\n         * The calling to execute.\n         * @member {Function}\n         */\n        this.context = context;\n\n        /**\n         * The current priority.\n         * @member {number}\n         */\n        this.priority = priority;\n\n        /**\n         * If this should only execute once.\n         * @member {boolean}\n         */\n        this.once = once;\n\n        /**\n         * The next item in chain.\n         * @member {TickerListener}\n         */\n        this.next = null;\n\n        /**\n         * The previous item in chain.\n         * @member {TickerListener}\n         */\n        this.previous = null;\n\n        /**\n         * `true` if this listener has been destroyed already.\n         * @member {boolean}\n         * @private\n         */\n        this._destroyed = false;\n    }\n\n    /**\n     * Simple compare function to figure out if a function and context match.\n     *\n     * @param {Function} fn - The listener function to be added for one update\n     * @param {Function} context - The listener context\n     * @return {boolean} `true` if the listener match the arguments\n     */\n\n\n    TickerListener.prototype.match = function match(fn, context) {\n        context = context || null;\n\n        return this.fn === fn && this.context === context;\n    };\n\n    /**\n     * Emit by calling the current function.\n     * @param {number} deltaTime - time since the last emit.\n     * @return {TickerListener} Next ticker\n     */\n\n\n    TickerListener.prototype.emit = function emit(deltaTime) {\n        if (this.fn) {\n            if (this.context) {\n                this.fn.call(this.context, deltaTime);\n            } else {\n                this.fn(deltaTime);\n            }\n        }\n\n        var redirect = this.next;\n\n        if (this.once) {\n            this.destroy(true);\n        }\n\n        // Soft-destroying should remove\n        // the next reference\n        if (this._destroyed) {\n            this.next = null;\n        }\n\n        return redirect;\n    };\n\n    /**\n     * Connect to the list.\n     * @param {TickerListener} previous - Input node, previous listener\n     */\n\n\n    TickerListener.prototype.connect = function connect(previous) {\n        this.previous = previous;\n        if (previous.next) {\n            previous.next.previous = this;\n        }\n        this.next = previous.next;\n        previous.next = this;\n    };\n\n    /**\n     * Destroy and don't use after this.\n     * @param {boolean} [hard = false] `true` to remove the `next` reference, this\n     *        is considered a hard destroy. Soft destroy maintains the next reference.\n     * @return {TickerListener} The listener to redirect while emitting or removing.\n     */\n\n\n    TickerListener.prototype.destroy = function destroy() {\n        var hard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n        this._destroyed = true;\n        this.fn = null;\n        this.context = null;\n\n        // Disconnect, hook up next and previous\n        if (this.previous) {\n            this.previous.next = this.next;\n        }\n\n        if (this.next) {\n            this.next.previous = this.previous;\n        }\n\n        // Redirect to the next item\n        var redirect = this.next;\n\n        // Remove references\n        this.next = hard ? null : redirect;\n        this.previous = null;\n\n        return redirect;\n    };\n\n    return TickerListener;\n}();\n\nexports.default = TickerListener;\n","map":{"version":3,"sources":["../../../src/core/ticker/TickerListener.js"],"names":["TickerListener","fn","context","priority","once","next","previous","_destroyed","match","emit","deltaTime","call","redirect","destroy","connect","hard"],"mappings":";;;;;;AAAA;;;;;;;IAOqBA,c;AAEjB;;;;;;;;AAQA,4BAAYC,EAAZ,EACA;AAAA,YADgBC,OAChB,uEAD0B,IAC1B;AAAA,YADgCC,QAChC,uEAD2C,CAC3C;AAAA,YAD8CC,IAC9C,uEADqD,KACrD;;AAAA;;AACI;;;;AAIA,aAAKH,EAAL,GAAUA,EAAV;;AAEA;;;;AAIA,aAAKC,OAAL,GAAeA,OAAf;;AAEA;;;;AAIA,aAAKC,QAAL,GAAgBA,QAAhB;;AAEA;;;;AAIA,aAAKC,IAAL,GAAYA,IAAZ;;AAEA;;;;AAIA,aAAKC,IAAL,GAAY,IAAZ;;AAEA;;;;AAIA,aAAKC,QAAL,GAAgB,IAAhB;;AAEA;;;;;AAKA,aAAKC,UAAL,GAAkB,KAAlB;AACH;;AAED;;;;;;;;;6BAOAC,K,kBAAMP,E,EAAIC,O,EACV;AACIA,kBAAUA,WAAW,IAArB;;AAEA,eAAO,KAAKD,EAAL,KAAYA,EAAZ,IAAkB,KAAKC,OAAL,KAAiBA,OAA1C;AACH,K;;AAED;;;;;;;6BAKAO,I,iBAAKC,S,EACL;AACI,YAAI,KAAKT,EAAT,EACA;AACI,gBAAI,KAAKC,OAAT,EACA;AACI,qBAAKD,EAAL,CAAQU,IAAR,CAAa,KAAKT,OAAlB,EAA2BQ,SAA3B;AACH,aAHD,MAKA;AACI,qBAAKT,EAAL,CAAQS,SAAR;AACH;AACJ;;AAED,YAAME,WAAW,KAAKP,IAAtB;;AAEA,YAAI,KAAKD,IAAT,EACA;AACI,iBAAKS,OAAL,CAAa,IAAb;AACH;;AAED;AACA;AACA,YAAI,KAAKN,UAAT,EACA;AACI,iBAAKF,IAAL,GAAY,IAAZ;AACH;;AAED,eAAOO,QAAP;AACH,K;;AAED;;;;;;6BAIAE,O,oBAAQR,Q,EACR;AACI,aAAKA,QAAL,GAAgBA,QAAhB;AACA,YAAIA,SAASD,IAAb,EACA;AACIC,qBAASD,IAAT,CAAcC,QAAd,GAAyB,IAAzB;AACH;AACD,aAAKD,IAAL,GAAYC,SAASD,IAArB;AACAC,iBAASD,IAAT,GAAgB,IAAhB;AACH,K;;AAED;;;;;;;;6BAMAQ,O,sBACA;AAAA,YADQE,IACR,uEADe,KACf;;AACI,aAAKR,UAAL,GAAkB,IAAlB;AACA,aAAKN,EAAL,GAAU,IAAV;AACA,aAAKC,OAAL,GAAe,IAAf;;AAEA;AACA,YAAI,KAAKI,QAAT,EACA;AACI,iBAAKA,QAAL,CAAcD,IAAd,GAAqB,KAAKA,IAA1B;AACH;;AAED,YAAI,KAAKA,IAAT,EACA;AACI,iBAAKA,IAAL,CAAUC,QAAV,GAAqB,KAAKA,QAA1B;AACH;;AAED;AACA,YAAMM,WAAW,KAAKP,IAAtB;;AAEA;AACA,aAAKA,IAAL,GAAYU,OAAO,IAAP,GAAcH,QAA1B;AACA,aAAKN,QAAL,GAAgB,IAAhB;;AAEA,eAAOM,QAAP;AACH,K;;;;;kBAxJgBZ,c","file":"TickerListener.js","sourcesContent":["/**\n * Internal class for handling the priority sorting of ticker handlers.\n *\n * @private\n * @class\n * @memberof PIXI.ticker\n */\nexport default class TickerListener\n{\n    /**\n     * Constructor\n     *\n     * @param {Function} fn - The listener function to be added for one update\n     * @param {Function} [context=null] - The listener context\n     * @param {number} [priority=0] - The priority for emitting\n     * @param {boolean} [once=false] - If the handler should fire once\n     */\n    constructor(fn, context = null, priority = 0, once = false)\n    {\n        /**\n         * The handler function to execute.\n         * @member {Function}\n         */\n        this.fn = fn;\n\n        /**\n         * The calling to execute.\n         * @member {Function}\n         */\n        this.context = context;\n\n        /**\n         * The current priority.\n         * @member {number}\n         */\n        this.priority = priority;\n\n        /**\n         * If this should only execute once.\n         * @member {boolean}\n         */\n        this.once = once;\n\n        /**\n         * The next item in chain.\n         * @member {TickerListener}\n         */\n        this.next = null;\n\n        /**\n         * The previous item in chain.\n         * @member {TickerListener}\n         */\n        this.previous = null;\n\n        /**\n         * `true` if this listener has been destroyed already.\n         * @member {boolean}\n         * @private\n         */\n        this._destroyed = false;\n    }\n\n    /**\n     * Simple compare function to figure out if a function and context match.\n     *\n     * @param {Function} fn - The listener function to be added for one update\n     * @param {Function} context - The listener context\n     * @return {boolean} `true` if the listener match the arguments\n     */\n    match(fn, context)\n    {\n        context = context || null;\n\n        return this.fn === fn && this.context === context;\n    }\n\n    /**\n     * Emit by calling the current function.\n     * @param {number} deltaTime - time since the last emit.\n     * @return {TickerListener} Next ticker\n     */\n    emit(deltaTime)\n    {\n        if (this.fn)\n        {\n            if (this.context)\n            {\n                this.fn.call(this.context, deltaTime);\n            }\n            else\n            {\n                this.fn(deltaTime);\n            }\n        }\n\n        const redirect = this.next;\n\n        if (this.once)\n        {\n            this.destroy(true);\n        }\n\n        // Soft-destroying should remove\n        // the next reference\n        if (this._destroyed)\n        {\n            this.next = null;\n        }\n\n        return redirect;\n    }\n\n    /**\n     * Connect to the list.\n     * @param {TickerListener} previous - Input node, previous listener\n     */\n    connect(previous)\n    {\n        this.previous = previous;\n        if (previous.next)\n        {\n            previous.next.previous = this;\n        }\n        this.next = previous.next;\n        previous.next = this;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @param {boolean} [hard = false] `true` to remove the `next` reference, this\n     *        is considered a hard destroy. Soft destroy maintains the next reference.\n     * @return {TickerListener} The listener to redirect while emitting or removing.\n     */\n    destroy(hard = false)\n    {\n        this._destroyed = true;\n        this.fn = null;\n        this.context = null;\n\n        // Disconnect, hook up next and previous\n        if (this.previous)\n        {\n            this.previous.next = this.next;\n        }\n\n        if (this.next)\n        {\n            this.next.previous = this.previous;\n        }\n\n        // Redirect to the next item\n        const redirect = this.next;\n\n        // Remove references\n        this.next = hard ? null : redirect;\n        this.previous = null;\n\n        return redirect;\n    }\n}\n"]}},"hash":"2ee13a35731aa36220108c77717c59db","cacheData":{"env":{}}}