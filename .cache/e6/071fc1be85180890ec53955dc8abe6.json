{"id":"../node_modules/pixi.js/lib/filters/displacement/DisplacementFilter.js","dependencies":[{"name":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/lib/filters/displacement/DisplacementFilter.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/antoine/Documents/perso/gamedev/GGJ19/package.json","includedInParent":true,"mtime":1548542467768},{"name":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/package.json","includedInParent":true,"mtime":1548541995508},{"name":"../../core","loc":{"line":7,"column":20},"parent":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/lib/filters/displacement/DisplacementFilter.js","resolved":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/lib/core/index.js"},{"name":"path","loc":{"line":11,"column":20},"parent":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/pixi.js/lib/filters/displacement/DisplacementFilter.js","resolved":"/Users/antoine/Documents/perso/gamedev/GGJ19/node_modules/path-browserify/index.js"}],"generated":{"js":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _core = require('../../core');\n\nvar core = _interopRequireWildcard(_core);\n\nvar _path = require('path');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * The DisplacementFilter class uses the pixel values from the specified texture\n * (called the displacement map) to perform a displacement of an object. You can\n * use this filter to apply all manor of crazy warping effects. Currently the r\n * property of the texture is used to offset the x and the g property of the texture\n * is used to offset the y.\n *\n * @class\n * @extends PIXI.Filter\n * @memberof PIXI.filters\n */\nvar DisplacementFilter = function (_core$Filter) {\n    _inherits(DisplacementFilter, _core$Filter);\n\n    /**\n     * @param {PIXI.Sprite} sprite - The sprite used for the displacement map. (make sure its added to the scene!)\n     * @param {number} scale - The scale of the displacement\n     */\n    function DisplacementFilter(sprite, scale) {\n        _classCallCheck(this, DisplacementFilter);\n\n        var maskMatrix = new core.Matrix();\n\n        sprite.renderable = false;\n\n        var _this = _possibleConstructorReturn(this, _core$Filter.call(this,\n        // vertex shader\n        'attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 filterMatrix;\\n\\nvarying vec2 vTextureCoord;\\nvarying vec2 vFilterCoord;\\n\\nvoid main(void)\\n{\\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;\\n   vTextureCoord = aTextureCoord;\\n}',\n        // fragment shader\n        'varying vec2 vFilterCoord;\\nvarying vec2 vTextureCoord;\\n\\nuniform vec2 scale;\\n\\nuniform sampler2D uSampler;\\nuniform sampler2D mapSampler;\\n\\nuniform vec4 filterArea;\\nuniform vec4 filterClamp;\\n\\nvoid main(void)\\n{\\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\\n\\n  map -= 0.5;\\n  map.xy *= scale / filterArea.xy;\\n\\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), filterClamp.xy, filterClamp.zw));\\n}\\n'));\n\n        _this.maskSprite = sprite;\n        _this.maskMatrix = maskMatrix;\n\n        _this.uniforms.mapSampler = sprite._texture;\n        _this.uniforms.filterMatrix = maskMatrix;\n        _this.uniforms.scale = { x: 1, y: 1 };\n\n        if (scale === null || scale === undefined) {\n            scale = 20;\n        }\n\n        _this.scale = new core.Point(scale, scale);\n        return _this;\n    }\n\n    /**\n     * Applies the filter.\n     *\n     * @param {PIXI.FilterManager} filterManager - The manager.\n     * @param {PIXI.RenderTarget} input - The input target.\n     * @param {PIXI.RenderTarget} output - The output target.\n     */\n\n\n    DisplacementFilter.prototype.apply = function apply(filterManager, input, output) {\n        this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);\n        this.uniforms.scale.x = this.scale.x;\n        this.uniforms.scale.y = this.scale.y;\n\n        // draw the filter...\n        filterManager.applyFilter(this, input, output);\n    };\n\n    /**\n     * The texture used for the displacement map. Must be power of 2 sized texture.\n     *\n     * @member {PIXI.Texture}\n     */\n\n\n    _createClass(DisplacementFilter, [{\n        key: 'map',\n        get: function get() {\n            return this.uniforms.mapSampler;\n        },\n        set: function set(value) // eslint-disable-line require-jsdoc\n        {\n            this.uniforms.mapSampler = value;\n        }\n    }]);\n\n    return DisplacementFilter;\n}(core.Filter);\n\nexports.default = DisplacementFilter;\n","map":{"version":3,"sources":["../../../src/filters/displacement/DisplacementFilter.js"],"names":["core","DisplacementFilter","sprite","scale","maskMatrix","Matrix","renderable","maskSprite","uniforms","mapSampler","_texture","filterMatrix","x","y","undefined","Point","apply","filterManager","input","output","calculateSpriteMatrix","applyFilter","value","Filter"],"mappings":";;;;;;AAAA;;IAAYA,I;;AAEZ;;;;;;;;;;AAEA;;;;;;;;;;;IAWqBC,kB;;;AAEjB;;;;AAIA,gCAAYC,MAAZ,EAAoBC,KAApB,EACA;AAAA;;AACI,YAAMC,aAAa,IAAIJ,KAAKK,MAAT,EAAnB;;AAEAH,eAAOI,UAAP,GAAoB,KAApB;;AAHJ,qDAKI;AACI;AADJ;AAGI;AAHJ,0dALJ;;AAYI,cAAKC,UAAL,GAAkBL,MAAlB;AACA,cAAKE,UAAL,GAAkBA,UAAlB;;AAEA,cAAKI,QAAL,CAAcC,UAAd,GAA2BP,OAAOQ,QAAlC;AACA,cAAKF,QAAL,CAAcG,YAAd,GAA6BP,UAA7B;AACA,cAAKI,QAAL,CAAcL,KAAd,GAAsB,EAAES,GAAG,CAAL,EAAQC,GAAG,CAAX,EAAtB;;AAEA,YAAIV,UAAU,IAAV,IAAkBA,UAAUW,SAAhC,EACA;AACIX,oBAAQ,EAAR;AACH;;AAED,cAAKA,KAAL,GAAa,IAAIH,KAAKe,KAAT,CAAeZ,KAAf,EAAsBA,KAAtB,CAAb;AAxBJ;AAyBC;;AAED;;;;;;;;;iCAOAa,K,kBAAMC,a,EAAeC,K,EAAOC,M,EAC5B;AACI,aAAKX,QAAL,CAAcG,YAAd,GAA6BM,cAAcG,qBAAd,CAAoC,KAAKhB,UAAzC,EAAqD,KAAKG,UAA1D,CAA7B;AACA,aAAKC,QAAL,CAAcL,KAAd,CAAoBS,CAApB,GAAwB,KAAKT,KAAL,CAAWS,CAAnC;AACA,aAAKJ,QAAL,CAAcL,KAAd,CAAoBU,CAApB,GAAwB,KAAKV,KAAL,CAAWU,CAAnC;;AAEC;AACDI,sBAAcI,WAAd,CAA0B,IAA1B,EAAgCH,KAAhC,EAAuCC,MAAvC;AACH,K;;AAED;;;;;;;;;4BAMA;AACI,mBAAO,KAAKX,QAAL,CAAcC,UAArB;AACH,S;0BAEOa,K,EAAO;AACf;AACI,iBAAKd,QAAL,CAAcC,UAAd,GAA2Ba,KAA3B;AACH;;;;EAhE2CtB,KAAKuB,M;;kBAAhCtB,kB","file":"DisplacementFilter.js","sourcesContent":["import * as core from '../../core';\nimport { readFileSync } from 'fs';\nimport { join } from 'path';\n\n/**\n * The DisplacementFilter class uses the pixel values from the specified texture\n * (called the displacement map) to perform a displacement of an object. You can\n * use this filter to apply all manor of crazy warping effects. Currently the r\n * property of the texture is used to offset the x and the g property of the texture\n * is used to offset the y.\n *\n * @class\n * @extends PIXI.Filter\n * @memberof PIXI.filters\n */\nexport default class DisplacementFilter extends core.Filter\n{\n    /**\n     * @param {PIXI.Sprite} sprite - The sprite used for the displacement map. (make sure its added to the scene!)\n     * @param {number} scale - The scale of the displacement\n     */\n    constructor(sprite, scale)\n    {\n        const maskMatrix = new core.Matrix();\n\n        sprite.renderable = false;\n\n        super(\n            // vertex shader\n            readFileSync(join(__dirname, '../fragments/default-filter-matrix.vert'), 'utf8'),\n            // fragment shader\n            readFileSync(join(__dirname, './displacement.frag'), 'utf8')\n        );\n\n        this.maskSprite = sprite;\n        this.maskMatrix = maskMatrix;\n\n        this.uniforms.mapSampler = sprite._texture;\n        this.uniforms.filterMatrix = maskMatrix;\n        this.uniforms.scale = { x: 1, y: 1 };\n\n        if (scale === null || scale === undefined)\n        {\n            scale = 20;\n        }\n\n        this.scale = new core.Point(scale, scale);\n    }\n\n    /**\n     * Applies the filter.\n     *\n     * @param {PIXI.FilterManager} filterManager - The manager.\n     * @param {PIXI.RenderTarget} input - The input target.\n     * @param {PIXI.RenderTarget} output - The output target.\n     */\n    apply(filterManager, input, output)\n    {\n        this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);\n        this.uniforms.scale.x = this.scale.x;\n        this.uniforms.scale.y = this.scale.y;\n\n         // draw the filter...\n        filterManager.applyFilter(this, input, output);\n    }\n\n    /**\n     * The texture used for the displacement map. Must be power of 2 sized texture.\n     *\n     * @member {PIXI.Texture}\n     */\n    get map()\n    {\n        return this.uniforms.mapSampler;\n    }\n\n    set map(value) // eslint-disable-line require-jsdoc\n    {\n        this.uniforms.mapSampler = value;\n    }\n}\n"]}},"hash":"aed067f3ec3417869b93e67bbbada341","cacheData":{"env":{}}}